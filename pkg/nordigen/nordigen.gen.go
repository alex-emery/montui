// Package nordigen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.4 DO NOT EDIT.
package nordigen

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	JwtAuthScopes = "jwtAuth.Scopes"
)

// Defines values for AccountStatusEnum.
const (
	DISCOVERED AccountStatusEnum = "DISCOVERED"
	ERROR      AccountStatusEnum = "ERROR"
	PROCESSING AccountStatusEnum = "PROCESSING"
	READY      AccountStatusEnum = "READY"
	SUSPENDED  AccountStatusEnum = "SUSPENDED"
)

// Defines values for Status1c5Enum.
const (
	CR Status1c5Enum = "CR"
	ER Status1c5Enum = "ER"
	EX Status1c5Enum = "EX"
	GA Status1c5Enum = "GA"
	GC Status1c5Enum = "GC"
	ID Status1c5Enum = "ID"
	LN Status1c5Enum = "LN"
	RJ Status1c5Enum = "RJ"
	SA Status1c5Enum = "SA"
	SU Status1c5Enum = "SU"
	UA Status1c5Enum = "UA"
)

// Account The representation of a bank account.
type Account struct {
	// Created The date & time at which the account object was created.
	Created *time.Time `json:"created,omitempty"`

	// Iban The Account IBAN
	Iban *string `json:"iban,omitempty"`

	// Id The ID of this Account, used to refer to this account in other API calls.
	Id *openapi_types.UUID `json:"id,omitempty"`

	// InstitutionId The ASPSP associated with this account.
	InstitutionId *string `json:"institution_id,omitempty"`

	// LastAccessed The date & time at which the account object was last accessed.
	LastAccessed *time.Time `json:"last_accessed"`

	// OwnerName The name of the account owner.
	OwnerName *string `json:"owner_name,omitempty"`

	// Status The processing status of this account.
	Status *AccountStatusEnum `json:"status,omitempty"`
}

// AccountBalanceSchema defines model for AccountBalanceSchema.
type AccountBalanceSchema struct {
	Balances *[]BalanceSchema `json:"balances,omitempty"`
}

// AccountDetailSchema defines model for AccountDetailSchema.
type AccountDetailSchema struct {
	// Account account
	Account DetailSchema `json:"account"`
}

// AccountSchema defines model for AccountSchema.
type AccountSchema struct {
	// Bban bban
	Bban *string `json:"bban,omitempty"`

	// Currency currency
	Currency *string `json:"currency,omitempty"`

	// Iban iban
	Iban *string `json:"iban,omitempty"`

	// MaskedPan maskedPan
	MaskedPan *string `json:"maskedPan,omitempty"`

	// Msisdn msisdn
	Msisdn *string `json:"msisdn,omitempty"`

	// Pan pan
	Pan *string `json:"pan,omitempty"`
}

// AccountStatusEnum defines model for AccountStatusEnum.
type AccountStatusEnum string

// BalanceAmountSchema defines model for BalanceAmountSchema.
type BalanceAmountSchema struct {
	// Amount amount
	Amount string `json:"amount"`

	// Currency currency
	Currency string `json:"currency"`
}

// BalanceSchema defines model for BalanceSchema.
type BalanceSchema struct {
	// BalanceAmount balanceAmount
	BalanceAmount BalanceAmountSchema `json:"balanceAmount"`

	// BalanceType balanceType
	BalanceType string `json:"balanceType"`

	// CreditLimitIncluded creditLimitIncluded
	CreditLimitIncluded *bool `json:"creditLimitIncluded,omitempty"`

	// LastChangeDateTime lastChangeDateTime
	LastChangeDateTime *string `json:"lastChangeDateTime,omitempty"`

	// LastCommittedTransaction lastCommittedTransaction
	LastCommittedTransaction *string `json:"lastCommittedTransaction,omitempty"`

	// ReferenceDate referenceDate
	ReferenceDate *string `json:"referenceDate,omitempty"`
}

// BankTransactionStatusSchema defines model for BankTransactionStatusSchema.
type BankTransactionStatusSchema struct {
	Transactions BankTransactionStatusSchemaTransactions `json:"transactions"`
}

// BankTransactionStatusSchemaTransactions defines model for BankTransactionStatusSchemaTransactions.
type BankTransactionStatusSchemaTransactions struct {
	Booked  []TransactionSchema  `json:"booked"`
	Pending *[]TransactionSchema `json:"pending,omitempty"`
}

// CurrencyExchangeSchema defines model for CurrencyExchangeSchema.
type CurrencyExchangeSchema struct {
	// ContractIdentification contractIdentification
	ContractIdentification *string `json:"contractIdentification,omitempty"`

	// ExchangeRate exchangeRate
	ExchangeRate *string `json:"exchangeRate,omitempty"`

	// QuotationDate quotationDate
	QuotationDate *string `json:"quotationDate,omitempty"`

	// SourceCurrency sourceCurrency
	SourceCurrency *string `json:"sourceCurrency,omitempty"`

	// TargetCurrency targetCurrency
	TargetCurrency *string `json:"targetCurrency,omitempty"`

	// UnitCurrency unitCurrency
	UnitCurrency *string `json:"unitCurrency,omitempty"`
}

// DetailSchema defines model for DetailSchema.
type DetailSchema struct {
	// Bban bban
	Bban *string `json:"bban,omitempty"`

	// Bic bic
	Bic *string `json:"bic,omitempty"`

	// CashAccountType cashAccountType
	CashAccountType *string `json:"cashAccountType,omitempty"`

	// Currency currency
	Currency *string `json:"currency,omitempty"`

	// Details details
	Details *string `json:"details,omitempty"`

	// DisplayName displayName
	DisplayName *string `json:"displayName,omitempty"`

	// Iban iban
	Iban *string `json:"iban,omitempty"`

	// LinkedAccounts linkedAccounts
	LinkedAccounts *string `json:"linkedAccounts,omitempty"`

	// MaskedPan maskedPan
	MaskedPan *string `json:"maskedPan,omitempty"`

	// Msisdn msisdn
	Msisdn *string `json:"msisdn,omitempty"`

	// Name name
	Name *string `json:"name,omitempty"`

	// OwnerAddressStructured ownerAddressStructured
	OwnerAddressStructured *OwnerAddressStructuredSchema `json:"ownerAddressStructured,omitempty"`

	// OwnerAddressUnstructured ownerAddressUnstructured
	OwnerAddressUnstructured *[]string `json:"ownerAddressUnstructured,omitempty"`

	// OwnerName ownerName
	OwnerName *string `json:"ownerName,omitempty"`

	// Product product
	Product *string `json:"product,omitempty"`

	// ResourceId resourceId
	ResourceId *string `json:"resourceId,omitempty"`

	// Status status
	Status *string `json:"status,omitempty"`

	// Usage usage
	Usage *string `json:"usage,omitempty"`
}

// EndUserAgreement Represents an end-user agreement.
type EndUserAgreement struct {
	// Accepted The date & time at which the end user accepted the agreement.
	Accepted *time.Time `json:"accepted"`

	// AccessScope Array containing one or several values of ['balances', 'details', 'transactions']
	AccessScope *[]interface{} `json:"access_scope,omitempty"`

	// AccessValidForDays Number of days from acceptance that the access can be used.
	AccessValidForDays *int `json:"access_valid_for_days,omitempty"`

	// Created The date & time at which the end user agreement was created.
	Created *time.Time `json:"created,omitempty"`

	// Id The ID of this End User Agreement, used to refer to this end user agreement in other API calls.
	Id *openapi_types.UUID `json:"id,omitempty"`

	// InstitutionId an Institution ID for this EUA
	InstitutionId string `json:"institution_id"`

	// MaxHistoricalDays Maximum number of days of transaction data to retrieve.
	MaxHistoricalDays *int `json:"max_historical_days,omitempty"`
}

// EndUserAgreementRequest Represents an end-user agreement.
type EndUserAgreementRequest struct {
	// AccessScope Array containing one or several values of ['balances', 'details', 'transactions']
	AccessScope *[]interface{} `json:"access_scope,omitempty"`

	// AccessValidForDays Number of days from acceptance that the access can be used.
	AccessValidForDays *int `json:"access_valid_for_days,omitempty"`

	// InstitutionId an Institution ID for this EUA
	InstitutionId string `json:"institution_id"`

	// MaxHistoricalDays Maximum number of days of transaction data to retrieve.
	MaxHistoricalDays *int `json:"max_historical_days,omitempty"`
}

// EnduserAcceptanceDetailsRequest Represents end-user details.
type EnduserAcceptanceDetailsRequest struct {
	IpAddress string `json:"ip_address"`
	UserAgent string `json:"user_agent"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Detail     string  `json:"detail"`
	StatusCode int     `json:"status_code"`
	Summary    string  `json:"summary"`
	Type       *string `json:"type,omitempty"`
}

// Integration Represents an Integration.
type Integration struct {
	Bic                  *string  `json:"bic,omitempty"`
	Countries            []string `json:"countries"`
	Id                   string   `json:"id"`
	Logo                 string   `json:"logo"`
	Name                 string   `json:"name"`
	TransactionTotalDays *string  `json:"transaction_total_days,omitempty"`
}

// IntegrationRetrieve IntegrationSerializer for Retrieve endpoint.
type IntegrationRetrieve struct {
	Bic                  *string                `json:"bic,omitempty"`
	Countries            []string               `json:"countries"`
	Id                   string                 `json:"id"`
	IdentificationCodes  []interface{}          `json:"identification_codes"`
	Logo                 string                 `json:"logo"`
	Name                 string                 `json:"name"`
	SupportedFeatures    []interface{}          `json:"supported_features"`
	SupportedPayments    map[string]interface{} `json:"supported_payments"`
	TransactionTotalDays *string                `json:"transaction_total_days,omitempty"`
}

// JWTObtainPairRequest Obtain JWT pair.
type JWTObtainPairRequest struct {
	// SecretId Secret id from /user-secrets/
	SecretId string `json:"secret_id"`

	// SecretKey Secret key from /user-secrets/
	SecretKey string `json:"secret_key"`
}

// JWTRefreshRequest Refresh access token.
type JWTRefreshRequest struct {
	Refresh string `json:"refresh"`
}

// OwnerAddressStructuredSchema defines model for OwnerAddressStructuredSchema.
type OwnerAddressStructuredSchema struct {
	// BuildingNumber buildingNumber
	BuildingNumber *string `json:"buildingNumber,omitempty"`

	// Country country
	Country *string `json:"country,omitempty"`

	// PostCode postCode
	PostCode *string `json:"postCode,omitempty"`

	// StreetName streetName
	StreetName *string `json:"streetName,omitempty"`

	// TownName townName
	TownName *string `json:"townName,omitempty"`
}

// PaginatedEndUserAgreementList defines model for PaginatedEndUserAgreementList.
type PaginatedEndUserAgreementList struct {
	Count    *int                `json:"count,omitempty"`
	Next     *string             `json:"next"`
	Previous *string             `json:"previous"`
	Results  *[]EndUserAgreement `json:"results,omitempty"`
}

// PaginatedRequisitionList defines model for PaginatedRequisitionList.
type PaginatedRequisitionList struct {
	Count    *int           `json:"count,omitempty"`
	Next     *string        `json:"next"`
	Previous *string        `json:"previous"`
	Results  *[]Requisition `json:"results,omitempty"`
}

// Requisition RequisitionSerializer.
type Requisition struct {
	// AccountSelection option to enable account selection view for the end user
	AccountSelection *bool `json:"account_selection,omitempty"`

	// Accounts array of account IDs retrieved within a scope of this requisition
	Accounts *[]openapi_types.UUID `json:"accounts,omitempty"`

	// Agreement EUA associated with this requisition
	Agreement *openapi_types.UUID `json:"agreement,omitempty"`

	// Created The date & time at which the requisition was created.
	Created *time.Time          `json:"created"`
	Id      *openapi_types.UUID `json:"id,omitempty"`

	// InstitutionId an Institution ID for this Requisition
	InstitutionId string `json:"institution_id"`

	// Link link to initiate authorization with Institution
	Link *string `json:"link,omitempty"`

	// Redirect redirect URL to your application after end-user authorization with ASPSP
	Redirect *string `json:"redirect"`

	// RedirectImmediate enable redirect back to the client after account list received
	RedirectImmediate *bool `json:"redirect_immediate,omitempty"`

	// Reference additional ID to identify the end user
	Reference *string `json:"reference,omitempty"`

	// Ssn optional SSN field to verify ownership of the account
	Ssn *string `json:"ssn,omitempty"`

	// Status status of this requisition
	Status *Status1c5Enum `json:"status,omitempty"`

	// UserLanguage A two-letter country code (ISO 639-1)
	UserLanguage *string `json:"user_language,omitempty"`
}

// RequisitionRequest RequisitionSerializer.
type RequisitionRequest struct {
	// AccountSelection option to enable account selection view for the end user
	AccountSelection *bool `json:"account_selection,omitempty"`

	// Agreement EUA associated with this requisition
	Agreement *openapi_types.UUID `json:"agreement,omitempty"`

	// InstitutionId an Institution ID for this Requisition
	InstitutionId string `json:"institution_id"`

	// Redirect redirect URL to your application after end-user authorization with ASPSP
	Redirect *string `json:"redirect"`

	// RedirectImmediate enable redirect back to the client after account list received
	RedirectImmediate *bool `json:"redirect_immediate,omitempty"`

	// Reference additional ID to identify the end user
	Reference *string `json:"reference,omitempty"`

	// Ssn optional SSN field to verify ownership of the account
	Ssn *string `json:"ssn,omitempty"`

	// UserLanguage A two-letter country code (ISO 639-1)
	UserLanguage *string `json:"user_language,omitempty"`
}

// SpectacularJWTObtain Obtain new JWT pair.
type SpectacularJWTObtain struct {
	// Access Your access token
	Access *string `json:"access,omitempty"`

	// AccessExpires Access token expires in seconds
	AccessExpires *int `json:"access_expires,omitempty"`

	// Refresh Your refresh token
	Refresh *string `json:"refresh,omitempty"`

	// RefreshExpires Refresh token expires in seconds
	RefreshExpires *int `json:"refresh_expires,omitempty"`
}

// SpectacularJWTRefresh Refresh Access token.
type SpectacularJWTRefresh struct {
	// Access Your access token
	Access *string `json:"access,omitempty"`

	// AccessExpires Access token expires in seconds
	AccessExpires *int `json:"access_expires,omitempty"`
}

// SpectacularRequisition Create requisition.
type SpectacularRequisition struct {
	// AccountSelection option to enable account selection view for the end user
	AccountSelection *bool `json:"account_selection,omitempty"`

	// Accounts array of account IDs retrieved within a scope of this requisition
	Accounts *[]interface{} `json:"accounts,omitempty"`

	// Agreement EUA associated with this requisition
	// Agreement *openapi_types.UUID `json:"agreement,omitempty"` //TODO: write a custom unmarshal, it can come through as an empty string

	// Created The date & time at which the requisition was created.
	Created *time.Time          `json:"created"`
	Id      *openapi_types.UUID `json:"id,omitempty"`

	// InstitutionId an Institution ID for this Requisition
	InstitutionId string `json:"institution_id"`

	// Link link to initiate authorization with Institution
	Link *string `json:"link,omitempty"`

	// Redirect redirect URL to your application after end-user authorization with ASPSP
	Redirect *string `json:"redirect"`

	// RedirectImmediate enable redirect back to the client after account list received
	RedirectImmediate *bool `json:"redirect_immediate,omitempty"`

	// Reference additional ID to identify the end user
	Reference *string `json:"reference,omitempty"`

	// Ssn optional SSN field to verify ownership of the account
	Ssn *string `json:"ssn,omitempty"`

	// Status status of this requisition
	Status *Status1c5Enum `json:"status,omitempty"`

	// UserLanguage A two-letter country code (ISO 639-1)
	UserLanguage *string `json:"user_language,omitempty"`
}

// Status1c5Enum defines model for Status1c5Enum.
type Status1c5Enum string

// TransactionAmountSchema defines model for TransactionAmountSchema.
type TransactionAmountSchema struct {
	// Amount amount
	Amount string `json:"amount"`

	// Currency currency
	Currency string `json:"currency"`
}

// TransactionSchema defines model for TransactionSchema.
type TransactionSchema struct {
	// AdditionalInformation additionalInformation
	AdditionalInformation *string `json:"additionalInformation,omitempty"`

	// BankTransactionCode bankTransactionCode
	BankTransactionCode *string `json:"bankTransactionCode,omitempty"`

	// BookingDate bookingDate
	BookingDate *string `json:"bookingDate,omitempty"`

	// BookingDateTime bookingDateTime
	BookingDateTime *string `json:"bookingDateTime,omitempty"`

	// CheckId checkId
	CheckId *string `json:"checkId,omitempty"`

	// CreditorAccount creditorAccount
	CreditorAccount *AccountSchema `json:"creditorAccount,omitempty"`

	// CreditorId creditorId
	CreditorId *string `json:"creditorId,omitempty"`

	// CreditorName creditorName
	CreditorName *string `json:"creditorName,omitempty"`

	// CurrencyExchange currencyExchange
	CurrencyExchange *CurrencyExchangeSchema `json:"currencyExchange,omitempty"`

	// DebtorAccount debtorAccount
	DebtorAccount *AccountSchema `json:"debtorAccount,omitempty"`

	// DebtorName debtorName
	DebtorName *string `json:"debtorName,omitempty"`

	// EndToEndId endToEndId
	EndToEndId *string `json:"endToEndId,omitempty"`

	// EntryReference entryReference
	EntryReference *string `json:"entryReference,omitempty"`

	// InternalTransactionId internalTransactionId
	InternalTransactionId *string `json:"internalTransactionId,omitempty"`

	// MandateId mandateId
	MandateId *string `json:"mandateId,omitempty"`

	// MerchantCategoryCode merchantCategoryCode
	MerchantCategoryCode *string `json:"merchantCategoryCode,omitempty"`

	// ProprietaryBankTransactionCode proprietaryBankTransactionCode
	ProprietaryBankTransactionCode *string `json:"proprietaryBankTransactionCode,omitempty"`

	// PurposeCode purposeCode
	PurposeCode *string `json:"purposeCode,omitempty"`

	// RemittanceInformationStructured remittanceInformationStructured
	RemittanceInformationStructured *string `json:"remittanceInformationStructured,omitempty"`

	// RemittanceInformationStructuredArray remittanceInformationStructuredArray
	RemittanceInformationStructuredArray *[]string `json:"remittanceInformationStructuredArray,omitempty"`

	// RemittanceInformationUnstructured remittanceInformationUnstructured
	RemittanceInformationUnstructured *string `json:"remittanceInformationUnstructured,omitempty"`

	// RemittanceInformationUnstructuredArray remittanceInformationUnstructuredArray
	RemittanceInformationUnstructuredArray *[]string `json:"remittanceInformationUnstructuredArray,omitempty"`

	// TransactionAmount transactionAmount
	TransactionAmount TransactionAmountSchema `json:"transactionAmount"`

	// TransactionId transactionId
	TransactionId *string `json:"transactionId,omitempty"`

	// UltimateCreditor ultimateCreditor
	UltimateCreditor *string `json:"ultimateCreditor,omitempty"`

	// UltimateDebtor ultimateDebtor
	UltimateDebtor *string `json:"ultimateDebtor,omitempty"`

	// ValueDate valueDate
	ValueDate *string `json:"valueDate,omitempty"`

	// ValueDateTime valueDateTime
	ValueDateTime *string `json:"valueDateTime,omitempty"`
}

// RetrieveAccountTransactionsPremiumParams defines parameters for RetrieveAccountTransactionsPremium.
type RetrieveAccountTransactionsPremiumParams struct {
	// Country ISO 3166 two-character country code
	Country  *string             `form:"country,omitempty" json:"country,omitempty"`
	DateFrom *openapi_types.Date `form:"date_from,omitempty" json:"date_from,omitempty"`
	DateTo   *openapi_types.Date `form:"date_to,omitempty" json:"date_to,omitempty"`
}

// RetrieveAccountTransactionsParams defines parameters for RetrieveAccountTransactions.
type RetrieveAccountTransactionsParams struct {
	DateFrom *openapi_types.Date `form:"date_from,omitempty" json:"date_from,omitempty"`
	DateTo   *openapi_types.Date `form:"date_to,omitempty" json:"date_to,omitempty"`
}

// RetrieveAllEUAsForAnEndUserParams defines parameters for RetrieveAllEUAsForAnEndUser.
type RetrieveAllEUAsForAnEndUserParams struct {
	// Limit Number of results to return per page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The initial index from which to return the results.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// RetrieveAllSupportedInstitutionsInAGivenCountryParams defines parameters for RetrieveAllSupportedInstitutionsInAGivenCountry.
type RetrieveAllSupportedInstitutionsInAGivenCountryParams struct {
	// AccessScopesSupported Boolean value, indicating if access scopes are supported
	AccessScopesSupported *string `form:"access_scopes_supported,omitempty" json:"access_scopes_supported,omitempty"`

	// AccountSelectionSupported Boolean value, indicating if account selection is supported
	AccountSelectionSupported *string `form:"account_selection_supported,omitempty" json:"account_selection_supported,omitempty"`

	// BusinessAccountsSupported Boolean value, indicating if business accounts are supported
	BusinessAccountsSupported *string `form:"business_accounts_supported,omitempty" json:"business_accounts_supported,omitempty"`

	// CardAccountsSupported Boolean value, indicating if card accounts are supported
	CardAccountsSupported *string `form:"card_accounts_supported,omitempty" json:"card_accounts_supported,omitempty"`

	// CorporateAccountsSupported Boolean value, indicating if corporate accounts are supported
	CorporateAccountsSupported *string `form:"corporate_accounts_supported,omitempty" json:"corporate_accounts_supported,omitempty"`

	// Country ISO 3166 two-character country code
	Country *string `form:"country,omitempty" json:"country,omitempty"`

	// PaymentSubmissionSupported Boolean value, indicating if payment submission is supported
	PaymentSubmissionSupported *string `form:"payment_submission_supported,omitempty" json:"payment_submission_supported,omitempty"`

	// PaymentsEnabled Boolean value, indicating if payments are supported
	PaymentsEnabled *string `form:"payments_enabled,omitempty" json:"payments_enabled,omitempty"`

	// PendingTransactionsSupported Boolean value, indicating if pending transactions are supported
	PendingTransactionsSupported *string `form:"pending_transactions_supported,omitempty" json:"pending_transactions_supported,omitempty"`

	// PrivateAccountsSupported Boolean value, indicating if private accounts are supported
	PrivateAccountsSupported *string `form:"private_accounts_supported,omitempty" json:"private_accounts_supported,omitempty"`

	// ReadRefundAccountSupported Boolean value, indicating if read refund account is supported
	ReadRefundAccountSupported *string `form:"read_refund_account_supported,omitempty" json:"read_refund_account_supported,omitempty"`

	// SsnVerificationSupported Boolean value, indicating if ssn verification is supported
	SsnVerificationSupported *string `form:"ssn_verification_supported,omitempty" json:"ssn_verification_supported,omitempty"`
}

// RetrieveAllRequisitionsParams defines parameters for RetrieveAllRequisitions.
type RetrieveAllRequisitionsParams struct {
	// Limit Number of results to return per page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The initial index from which to return the results.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// CreateEUAJSONRequestBody defines body for CreateEUA for application/json ContentType.
type CreateEUAJSONRequestBody = EndUserAgreementRequest

// CreateEUAFormdataRequestBody defines body for CreateEUA for application/x-www-form-urlencoded ContentType.
type CreateEUAFormdataRequestBody = EndUserAgreementRequest

// CreateEUAMultipartRequestBody defines body for CreateEUA for multipart/form-data ContentType.
type CreateEUAMultipartRequestBody = EndUserAgreementRequest

// AcceptEUAJSONRequestBody defines body for AcceptEUA for application/json ContentType.
type AcceptEUAJSONRequestBody = EnduserAcceptanceDetailsRequest

// AcceptEUAFormdataRequestBody defines body for AcceptEUA for application/x-www-form-urlencoded ContentType.
type AcceptEUAFormdataRequestBody = EnduserAcceptanceDetailsRequest

// AcceptEUAMultipartRequestBody defines body for AcceptEUA for multipart/form-data ContentType.
type AcceptEUAMultipartRequestBody = EnduserAcceptanceDetailsRequest

// CreateRequisitionJSONRequestBody defines body for CreateRequisition for application/json ContentType.
type CreateRequisitionJSONRequestBody = RequisitionRequest

// CreateRequisitionFormdataRequestBody defines body for CreateRequisition for application/x-www-form-urlencoded ContentType.
type CreateRequisitionFormdataRequestBody = RequisitionRequest

// CreateRequisitionMultipartRequestBody defines body for CreateRequisition for multipart/form-data ContentType.
type CreateRequisitionMultipartRequestBody = RequisitionRequest

// ObtainNewAccessrefreshTokenPairJSONRequestBody defines body for ObtainNewAccessrefreshTokenPair for application/json ContentType.
type ObtainNewAccessrefreshTokenPairJSONRequestBody = JWTObtainPairRequest

// ObtainNewAccessrefreshTokenPairFormdataRequestBody defines body for ObtainNewAccessrefreshTokenPair for application/x-www-form-urlencoded ContentType.
type ObtainNewAccessrefreshTokenPairFormdataRequestBody = JWTObtainPairRequest

// ObtainNewAccessrefreshTokenPairMultipartRequestBody defines body for ObtainNewAccessrefreshTokenPair for multipart/form-data ContentType.
type ObtainNewAccessrefreshTokenPairMultipartRequestBody = JWTObtainPairRequest

// GetANewAccessTokenJSONRequestBody defines body for GetANewAccessToken for application/json ContentType.
type GetANewAccessTokenJSONRequestBody = JWTRefreshRequest

// GetANewAccessTokenFormdataRequestBody defines body for GetANewAccessToken for application/x-www-form-urlencoded ContentType.
type GetANewAccessTokenFormdataRequestBody = JWTRefreshRequest

// GetANewAccessTokenMultipartRequestBody defines body for GetANewAccessToken for multipart/form-data ContentType.
type GetANewAccessTokenMultipartRequestBody = JWTRefreshRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// RetrieveAccountTransactionsPremium request
	RetrieveAccountTransactionsPremium(ctx context.Context, id openapi_types.UUID, params *RetrieveAccountTransactionsPremiumParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAccountMetadata request
	RetrieveAccountMetadata(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAccountBalances request
	RetrieveAccountBalances(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAccountDetails request
	RetrieveAccountDetails(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAccountTransactions request
	RetrieveAccountTransactions(ctx context.Context, id openapi_types.UUID, params *RetrieveAccountTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAllEUAsForAnEndUser request
	RetrieveAllEUAsForAnEndUser(ctx context.Context, params *RetrieveAllEUAsForAnEndUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEUAWithBody request with any body
	CreateEUAWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEUA(ctx context.Context, body CreateEUAJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEUAWithFormdataBody(ctx context.Context, body CreateEUAFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEUAById request
	DeleteEUAById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveEUAById request
	RetrieveEUAById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptEUAWithBody request with any body
	AcceptEUAWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AcceptEUA(ctx context.Context, id openapi_types.UUID, body AcceptEUAJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	AcceptEUAWithFormdataBody(ctx context.Context, id openapi_types.UUID, body AcceptEUAFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAllSupportedInstitutionsInAGivenCountry request
	RetrieveAllSupportedInstitutionsInAGivenCountry(ctx context.Context, params *RetrieveAllSupportedInstitutionsInAGivenCountryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveInstitution request
	RetrieveInstitution(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAllRequisitions request
	RetrieveAllRequisitions(ctx context.Context, params *RetrieveAllRequisitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRequisitionWithBody request with any body
	CreateRequisitionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRequisition(ctx context.Context, body CreateRequisitionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRequisitionWithFormdataBody(ctx context.Context, body CreateRequisitionFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRequisitionById request
	DeleteRequisitionById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequisitionById request
	RequisitionById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ObtainNewAccessrefreshTokenPairWithBody request with any body
	ObtainNewAccessrefreshTokenPairWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ObtainNewAccessrefreshTokenPair(ctx context.Context, body ObtainNewAccessrefreshTokenPairJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	ObtainNewAccessrefreshTokenPairWithFormdataBody(ctx context.Context, body ObtainNewAccessrefreshTokenPairFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetANewAccessTokenWithBody request with any body
	GetANewAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetANewAccessToken(ctx context.Context, body GetANewAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetANewAccessTokenWithFormdataBody(ctx context.Context, body GetANewAccessTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) RetrieveAccountTransactionsPremium(ctx context.Context, id openapi_types.UUID, params *RetrieveAccountTransactionsPremiumParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAccountTransactionsPremiumRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAccountMetadata(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAccountMetadataRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAccountBalances(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAccountBalancesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAccountDetails(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAccountDetailsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAccountTransactions(ctx context.Context, id openapi_types.UUID, params *RetrieveAccountTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAccountTransactionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAllEUAsForAnEndUser(ctx context.Context, params *RetrieveAllEUAsForAnEndUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAllEUAsForAnEndUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEUAWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEUARequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEUA(ctx context.Context, body CreateEUAJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEUARequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEUAWithFormdataBody(ctx context.Context, body CreateEUAFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEUARequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEUAById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEUAByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveEUAById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveEUAByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptEUAWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptEUARequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptEUA(ctx context.Context, id openapi_types.UUID, body AcceptEUAJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptEUARequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptEUAWithFormdataBody(ctx context.Context, id openapi_types.UUID, body AcceptEUAFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptEUARequestWithFormdataBody(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAllSupportedInstitutionsInAGivenCountry(ctx context.Context, params *RetrieveAllSupportedInstitutionsInAGivenCountryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAllSupportedInstitutionsInAGivenCountryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveInstitution(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveInstitutionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAllRequisitions(ctx context.Context, params *RetrieveAllRequisitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAllRequisitionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRequisitionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequisitionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRequisition(ctx context.Context, body CreateRequisitionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequisitionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRequisitionWithFormdataBody(ctx context.Context, body CreateRequisitionFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequisitionRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRequisitionById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRequisitionByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequisitionById(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequisitionByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObtainNewAccessrefreshTokenPairWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObtainNewAccessrefreshTokenPairRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObtainNewAccessrefreshTokenPair(ctx context.Context, body ObtainNewAccessrefreshTokenPairJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObtainNewAccessrefreshTokenPairRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObtainNewAccessrefreshTokenPairWithFormdataBody(ctx context.Context, body ObtainNewAccessrefreshTokenPairFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObtainNewAccessrefreshTokenPairRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetANewAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetANewAccessTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetANewAccessToken(ctx context.Context, body GetANewAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetANewAccessTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetANewAccessTokenWithFormdataBody(ctx context.Context, body GetANewAccessTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetANewAccessTokenRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewRetrieveAccountTransactionsPremiumRequest generates requests for RetrieveAccountTransactionsPremium
func NewRetrieveAccountTransactionsPremiumRequest(server string, id openapi_types.UUID, params *RetrieveAccountTransactionsPremiumParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/accounts/premium/%s/transactions/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Country != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country", runtime.ParamLocationQuery, *params.Country); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_from", runtime.ParamLocationQuery, *params.DateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_to", runtime.ParamLocationQuery, *params.DateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveAccountMetadataRequest generates requests for RetrieveAccountMetadata
func NewRetrieveAccountMetadataRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/accounts/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveAccountBalancesRequest generates requests for RetrieveAccountBalances
func NewRetrieveAccountBalancesRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/accounts/%s/balances/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveAccountDetailsRequest generates requests for RetrieveAccountDetails
func NewRetrieveAccountDetailsRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/accounts/%s/details/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveAccountTransactionsRequest generates requests for RetrieveAccountTransactions
func NewRetrieveAccountTransactionsRequest(server string, id openapi_types.UUID, params *RetrieveAccountTransactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/accounts/%s/transactions/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_from", runtime.ParamLocationQuery, *params.DateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_to", runtime.ParamLocationQuery, *params.DateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveAllEUAsForAnEndUserRequest generates requests for RetrieveAllEUAsForAnEndUser
func NewRetrieveAllEUAsForAnEndUserRequest(server string, params *RetrieveAllEUAsForAnEndUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/agreements/enduser/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEUARequest calls the generic CreateEUA builder with application/json body
func NewCreateEUARequest(server string, body CreateEUAJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEUARequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEUARequestWithFormdataBody calls the generic CreateEUA builder with application/x-www-form-urlencoded body
func NewCreateEUARequestWithFormdataBody(server string, body CreateEUAFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewCreateEUARequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewCreateEUARequestWithBody generates requests for CreateEUA with any type of body
func NewCreateEUARequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/agreements/enduser/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEUAByIdRequest generates requests for DeleteEUAById
func NewDeleteEUAByIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/agreements/enduser/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveEUAByIdRequest generates requests for RetrieveEUAById
func NewRetrieveEUAByIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/agreements/enduser/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcceptEUARequest calls the generic AcceptEUA builder with application/json body
func NewAcceptEUARequest(server string, id openapi_types.UUID, body AcceptEUAJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAcceptEUARequestWithBody(server, id, "application/json", bodyReader)
}

// NewAcceptEUARequestWithFormdataBody calls the generic AcceptEUA builder with application/x-www-form-urlencoded body
func NewAcceptEUARequestWithFormdataBody(server string, id openapi_types.UUID, body AcceptEUAFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewAcceptEUARequestWithBody(server, id, "application/x-www-form-urlencoded", bodyReader)
}

// NewAcceptEUARequestWithBody generates requests for AcceptEUA with any type of body
func NewAcceptEUARequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/agreements/enduser/%s/accept/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRetrieveAllSupportedInstitutionsInAGivenCountryRequest generates requests for RetrieveAllSupportedInstitutionsInAGivenCountry
func NewRetrieveAllSupportedInstitutionsInAGivenCountryRequest(server string, params *RetrieveAllSupportedInstitutionsInAGivenCountryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/institutions/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AccessScopesSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_scopes_supported", runtime.ParamLocationQuery, *params.AccessScopesSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccountSelectionSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_selection_supported", runtime.ParamLocationQuery, *params.AccountSelectionSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BusinessAccountsSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "business_accounts_supported", runtime.ParamLocationQuery, *params.BusinessAccountsSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CardAccountsSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "card_accounts_supported", runtime.ParamLocationQuery, *params.CardAccountsSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CorporateAccountsSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "corporate_accounts_supported", runtime.ParamLocationQuery, *params.CorporateAccountsSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Country != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country", runtime.ParamLocationQuery, *params.Country); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaymentSubmissionSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payment_submission_supported", runtime.ParamLocationQuery, *params.PaymentSubmissionSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaymentsEnabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payments_enabled", runtime.ParamLocationQuery, *params.PaymentsEnabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PendingTransactionsSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pending_transactions_supported", runtime.ParamLocationQuery, *params.PendingTransactionsSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateAccountsSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "private_accounts_supported", runtime.ParamLocationQuery, *params.PrivateAccountsSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReadRefundAccountSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "read_refund_account_supported", runtime.ParamLocationQuery, *params.ReadRefundAccountSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SsnVerificationSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ssn_verification_supported", runtime.ParamLocationQuery, *params.SsnVerificationSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveInstitutionRequest generates requests for RetrieveInstitution
func NewRetrieveInstitutionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/institutions/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveAllRequisitionsRequest generates requests for RetrieveAllRequisitions
func NewRetrieveAllRequisitionsRequest(server string, params *RetrieveAllRequisitionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/requisitions/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRequisitionRequest calls the generic CreateRequisition builder with application/json body
func NewCreateRequisitionRequest(server string, body CreateRequisitionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRequisitionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRequisitionRequestWithFormdataBody calls the generic CreateRequisition builder with application/x-www-form-urlencoded body
func NewCreateRequisitionRequestWithFormdataBody(server string, body CreateRequisitionFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewCreateRequisitionRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewCreateRequisitionRequestWithBody generates requests for CreateRequisition with any type of body
func NewCreateRequisitionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/requisitions/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRequisitionByIdRequest generates requests for DeleteRequisitionById
func NewDeleteRequisitionByIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/requisitions/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRequisitionByIdRequest generates requests for RequisitionById
func NewRequisitionByIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/requisitions/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewObtainNewAccessrefreshTokenPairRequest calls the generic ObtainNewAccessrefreshTokenPair builder with application/json body
func NewObtainNewAccessrefreshTokenPairRequest(server string, body ObtainNewAccessrefreshTokenPairJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewObtainNewAccessrefreshTokenPairRequestWithBody(server, "application/json", bodyReader)
}

// NewObtainNewAccessrefreshTokenPairRequestWithFormdataBody calls the generic ObtainNewAccessrefreshTokenPair builder with application/x-www-form-urlencoded body
func NewObtainNewAccessrefreshTokenPairRequestWithFormdataBody(server string, body ObtainNewAccessrefreshTokenPairFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewObtainNewAccessrefreshTokenPairRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewObtainNewAccessrefreshTokenPairRequestWithBody generates requests for ObtainNewAccessrefreshTokenPair with any type of body
func NewObtainNewAccessrefreshTokenPairRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/token/new/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetANewAccessTokenRequest calls the generic GetANewAccessToken builder with application/json body
func NewGetANewAccessTokenRequest(server string, body GetANewAccessTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetANewAccessTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewGetANewAccessTokenRequestWithFormdataBody calls the generic GetANewAccessToken builder with application/x-www-form-urlencoded body
func NewGetANewAccessTokenRequestWithFormdataBody(server string, body GetANewAccessTokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewGetANewAccessTokenRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewGetANewAccessTokenRequestWithBody generates requests for GetANewAccessToken with any type of body
func NewGetANewAccessTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/token/refresh/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// RetrieveAccountTransactionsPremiumWithResponse request
	RetrieveAccountTransactionsPremiumWithResponse(ctx context.Context, id openapi_types.UUID, params *RetrieveAccountTransactionsPremiumParams, reqEditors ...RequestEditorFn) (*RetrieveAccountTransactionsPremiumResponse, error)

	// RetrieveAccountMetadataWithResponse request
	RetrieveAccountMetadataWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RetrieveAccountMetadataResponse, error)

	// RetrieveAccountBalancesWithResponse request
	RetrieveAccountBalancesWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RetrieveAccountBalancesResponse, error)

	// RetrieveAccountDetailsWithResponse request
	RetrieveAccountDetailsWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RetrieveAccountDetailsResponse, error)

	// RetrieveAccountTransactionsWithResponse request
	RetrieveAccountTransactionsWithResponse(ctx context.Context, id openapi_types.UUID, params *RetrieveAccountTransactionsParams, reqEditors ...RequestEditorFn) (*RetrieveAccountTransactionsResponse, error)

	// RetrieveAllEUAsForAnEndUserWithResponse request
	RetrieveAllEUAsForAnEndUserWithResponse(ctx context.Context, params *RetrieveAllEUAsForAnEndUserParams, reqEditors ...RequestEditorFn) (*RetrieveAllEUAsForAnEndUserResponse, error)

	// CreateEUAWithBodyWithResponse request with any body
	CreateEUAWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEUAResponse, error)

	CreateEUAWithResponse(ctx context.Context, body CreateEUAJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEUAResponse, error)

	CreateEUAWithFormdataBodyWithResponse(ctx context.Context, body CreateEUAFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateEUAResponse, error)

	// DeleteEUAByIdWithResponse request
	DeleteEUAByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteEUAByIdResponse, error)

	// RetrieveEUAByIdWithResponse request
	RetrieveEUAByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RetrieveEUAByIdResponse, error)

	// AcceptEUAWithBodyWithResponse request with any body
	AcceptEUAWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptEUAResponse, error)

	AcceptEUAWithResponse(ctx context.Context, id openapi_types.UUID, body AcceptEUAJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptEUAResponse, error)

	AcceptEUAWithFormdataBodyWithResponse(ctx context.Context, id openapi_types.UUID, body AcceptEUAFormdataRequestBody, reqEditors ...RequestEditorFn) (*AcceptEUAResponse, error)

	// RetrieveAllSupportedInstitutionsInAGivenCountryWithResponse request
	RetrieveAllSupportedInstitutionsInAGivenCountryWithResponse(ctx context.Context, params *RetrieveAllSupportedInstitutionsInAGivenCountryParams, reqEditors ...RequestEditorFn) (*RetrieveAllSupportedInstitutionsInAGivenCountryResponse, error)

	// RetrieveInstitutionWithResponse request
	RetrieveInstitutionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetrieveInstitutionResponse, error)

	// RetrieveAllRequisitionsWithResponse request
	RetrieveAllRequisitionsWithResponse(ctx context.Context, params *RetrieveAllRequisitionsParams, reqEditors ...RequestEditorFn) (*RetrieveAllRequisitionsResponse, error)

	// CreateRequisitionWithBodyWithResponse request with any body
	CreateRequisitionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRequisitionResponse, error)

	CreateRequisitionWithResponse(ctx context.Context, body CreateRequisitionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRequisitionResponse, error)

	CreateRequisitionWithFormdataBodyWithResponse(ctx context.Context, body CreateRequisitionFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateRequisitionResponse, error)

	// DeleteRequisitionByIdWithResponse request
	DeleteRequisitionByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteRequisitionByIdResponse, error)

	// RequisitionByIdWithResponse request
	RequisitionByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RequisitionByIdResponse, error)

	// ObtainNewAccessrefreshTokenPairWithBodyWithResponse request with any body
	ObtainNewAccessrefreshTokenPairWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ObtainNewAccessrefreshTokenPairResponse, error)

	ObtainNewAccessrefreshTokenPairWithResponse(ctx context.Context, body ObtainNewAccessrefreshTokenPairJSONRequestBody, reqEditors ...RequestEditorFn) (*ObtainNewAccessrefreshTokenPairResponse, error)

	ObtainNewAccessrefreshTokenPairWithFormdataBodyWithResponse(ctx context.Context, body ObtainNewAccessrefreshTokenPairFormdataRequestBody, reqEditors ...RequestEditorFn) (*ObtainNewAccessrefreshTokenPairResponse, error)

	// GetANewAccessTokenWithBodyWithResponse request with any body
	GetANewAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetANewAccessTokenResponse, error)

	GetANewAccessTokenWithResponse(ctx context.Context, body GetANewAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*GetANewAccessTokenResponse, error)

	GetANewAccessTokenWithFormdataBodyWithResponse(ctx context.Context, body GetANewAccessTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*GetANewAccessTokenResponse, error)
}

type RetrieveAccountTransactionsPremiumResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BankTransactionStatusSchema
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveAccountTransactionsPremiumResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAccountTransactionsPremiumResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAccountMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Account
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveAccountMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAccountMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAccountBalancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountBalanceSchema
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveAccountBalancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAccountBalancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAccountDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountDetailSchema
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveAccountDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAccountDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAccountTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BankTransactionStatusSchema
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveAccountTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAccountTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAllEUAsForAnEndUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedEndUserAgreementList
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveAllEUAsForAnEndUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAllEUAsForAnEndUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEUAResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EndUserAgreement
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON402      *ErrorResponse
	JSON403      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateEUAResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEUAResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEUAByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteEUAByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEUAByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveEUAByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndUserAgreement
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveEUAByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveEUAByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptEUAResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndUserAgreement
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AcceptEUAResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptEUAResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAllSupportedInstitutionsInAGivenCountryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Integration
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveAllSupportedInstitutionsInAGivenCountryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAllSupportedInstitutionsInAGivenCountryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveInstitutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationRetrieve
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveInstitutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveInstitutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAllRequisitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedRequisitionList
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveAllRequisitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAllRequisitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRequisitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpectacularRequisition
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON402      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateRequisitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRequisitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRequisitionByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteRequisitionByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRequisitionByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequisitionByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Requisition
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RequisitionByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequisitionByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ObtainNewAccessrefreshTokenPairResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpectacularJWTObtain
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ObtainNewAccessrefreshTokenPairResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ObtainNewAccessrefreshTokenPairResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetANewAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpectacularJWTRefresh
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetANewAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetANewAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// RetrieveAccountTransactionsPremiumWithResponse request returning *RetrieveAccountTransactionsPremiumResponse
func (c *ClientWithResponses) RetrieveAccountTransactionsPremiumWithResponse(ctx context.Context, id openapi_types.UUID, params *RetrieveAccountTransactionsPremiumParams, reqEditors ...RequestEditorFn) (*RetrieveAccountTransactionsPremiumResponse, error) {
	rsp, err := c.RetrieveAccountTransactionsPremium(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAccountTransactionsPremiumResponse(rsp)
}

// RetrieveAccountMetadataWithResponse request returning *RetrieveAccountMetadataResponse
func (c *ClientWithResponses) RetrieveAccountMetadataWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RetrieveAccountMetadataResponse, error) {
	rsp, err := c.RetrieveAccountMetadata(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAccountMetadataResponse(rsp)
}

// RetrieveAccountBalancesWithResponse request returning *RetrieveAccountBalancesResponse
func (c *ClientWithResponses) RetrieveAccountBalancesWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RetrieveAccountBalancesResponse, error) {
	rsp, err := c.RetrieveAccountBalances(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAccountBalancesResponse(rsp)
}

// RetrieveAccountDetailsWithResponse request returning *RetrieveAccountDetailsResponse
func (c *ClientWithResponses) RetrieveAccountDetailsWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RetrieveAccountDetailsResponse, error) {
	rsp, err := c.RetrieveAccountDetails(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAccountDetailsResponse(rsp)
}

// RetrieveAccountTransactionsWithResponse request returning *RetrieveAccountTransactionsResponse
func (c *ClientWithResponses) RetrieveAccountTransactionsWithResponse(ctx context.Context, id openapi_types.UUID, params *RetrieveAccountTransactionsParams, reqEditors ...RequestEditorFn) (*RetrieveAccountTransactionsResponse, error) {
	rsp, err := c.RetrieveAccountTransactions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAccountTransactionsResponse(rsp)
}

// RetrieveAllEUAsForAnEndUserWithResponse request returning *RetrieveAllEUAsForAnEndUserResponse
func (c *ClientWithResponses) RetrieveAllEUAsForAnEndUserWithResponse(ctx context.Context, params *RetrieveAllEUAsForAnEndUserParams, reqEditors ...RequestEditorFn) (*RetrieveAllEUAsForAnEndUserResponse, error) {
	rsp, err := c.RetrieveAllEUAsForAnEndUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAllEUAsForAnEndUserResponse(rsp)
}

// CreateEUAWithBodyWithResponse request with arbitrary body returning *CreateEUAResponse
func (c *ClientWithResponses) CreateEUAWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEUAResponse, error) {
	rsp, err := c.CreateEUAWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEUAResponse(rsp)
}

func (c *ClientWithResponses) CreateEUAWithResponse(ctx context.Context, body CreateEUAJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEUAResponse, error) {
	rsp, err := c.CreateEUA(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEUAResponse(rsp)
}

func (c *ClientWithResponses) CreateEUAWithFormdataBodyWithResponse(ctx context.Context, body CreateEUAFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateEUAResponse, error) {
	rsp, err := c.CreateEUAWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEUAResponse(rsp)
}

// DeleteEUAByIdWithResponse request returning *DeleteEUAByIdResponse
func (c *ClientWithResponses) DeleteEUAByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteEUAByIdResponse, error) {
	rsp, err := c.DeleteEUAById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEUAByIdResponse(rsp)
}

// RetrieveEUAByIdWithResponse request returning *RetrieveEUAByIdResponse
func (c *ClientWithResponses) RetrieveEUAByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RetrieveEUAByIdResponse, error) {
	rsp, err := c.RetrieveEUAById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveEUAByIdResponse(rsp)
}

// AcceptEUAWithBodyWithResponse request with arbitrary body returning *AcceptEUAResponse
func (c *ClientWithResponses) AcceptEUAWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptEUAResponse, error) {
	rsp, err := c.AcceptEUAWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptEUAResponse(rsp)
}

func (c *ClientWithResponses) AcceptEUAWithResponse(ctx context.Context, id openapi_types.UUID, body AcceptEUAJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptEUAResponse, error) {
	rsp, err := c.AcceptEUA(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptEUAResponse(rsp)
}

func (c *ClientWithResponses) AcceptEUAWithFormdataBodyWithResponse(ctx context.Context, id openapi_types.UUID, body AcceptEUAFormdataRequestBody, reqEditors ...RequestEditorFn) (*AcceptEUAResponse, error) {
	rsp, err := c.AcceptEUAWithFormdataBody(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptEUAResponse(rsp)
}

// RetrieveAllSupportedInstitutionsInAGivenCountryWithResponse request returning *RetrieveAllSupportedInstitutionsInAGivenCountryResponse
func (c *ClientWithResponses) RetrieveAllSupportedInstitutionsInAGivenCountryWithResponse(ctx context.Context, params *RetrieveAllSupportedInstitutionsInAGivenCountryParams, reqEditors ...RequestEditorFn) (*RetrieveAllSupportedInstitutionsInAGivenCountryResponse, error) {
	rsp, err := c.RetrieveAllSupportedInstitutionsInAGivenCountry(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAllSupportedInstitutionsInAGivenCountryResponse(rsp)
}

// RetrieveInstitutionWithResponse request returning *RetrieveInstitutionResponse
func (c *ClientWithResponses) RetrieveInstitutionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetrieveInstitutionResponse, error) {
	rsp, err := c.RetrieveInstitution(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveInstitutionResponse(rsp)
}

// RetrieveAllRequisitionsWithResponse request returning *RetrieveAllRequisitionsResponse
func (c *ClientWithResponses) RetrieveAllRequisitionsWithResponse(ctx context.Context, params *RetrieveAllRequisitionsParams, reqEditors ...RequestEditorFn) (*RetrieveAllRequisitionsResponse, error) {
	rsp, err := c.RetrieveAllRequisitions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAllRequisitionsResponse(rsp)
}

// CreateRequisitionWithBodyWithResponse request with arbitrary body returning *CreateRequisitionResponse
func (c *ClientWithResponses) CreateRequisitionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRequisitionResponse, error) {
	rsp, err := c.CreateRequisitionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRequisitionResponse(rsp)
}

func (c *ClientWithResponses) CreateRequisitionWithResponse(ctx context.Context, body CreateRequisitionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRequisitionResponse, error) {
	rsp, err := c.CreateRequisition(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRequisitionResponse(rsp)
}

func (c *ClientWithResponses) CreateRequisitionWithFormdataBodyWithResponse(ctx context.Context, body CreateRequisitionFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateRequisitionResponse, error) {
	rsp, err := c.CreateRequisitionWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRequisitionResponse(rsp)
}

// DeleteRequisitionByIdWithResponse request returning *DeleteRequisitionByIdResponse
func (c *ClientWithResponses) DeleteRequisitionByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteRequisitionByIdResponse, error) {
	rsp, err := c.DeleteRequisitionById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRequisitionByIdResponse(rsp)
}

// RequisitionByIdWithResponse request returning *RequisitionByIdResponse
func (c *ClientWithResponses) RequisitionByIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RequisitionByIdResponse, error) {
	rsp, err := c.RequisitionById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequisitionByIdResponse(rsp)
}

// ObtainNewAccessrefreshTokenPairWithBodyWithResponse request with arbitrary body returning *ObtainNewAccessrefreshTokenPairResponse
func (c *ClientWithResponses) ObtainNewAccessrefreshTokenPairWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ObtainNewAccessrefreshTokenPairResponse, error) {
	rsp, err := c.ObtainNewAccessrefreshTokenPairWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObtainNewAccessrefreshTokenPairResponse(rsp)
}

func (c *ClientWithResponses) ObtainNewAccessrefreshTokenPairWithResponse(ctx context.Context, body ObtainNewAccessrefreshTokenPairJSONRequestBody, reqEditors ...RequestEditorFn) (*ObtainNewAccessrefreshTokenPairResponse, error) {
	rsp, err := c.ObtainNewAccessrefreshTokenPair(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObtainNewAccessrefreshTokenPairResponse(rsp)
}

func (c *ClientWithResponses) ObtainNewAccessrefreshTokenPairWithFormdataBodyWithResponse(ctx context.Context, body ObtainNewAccessrefreshTokenPairFormdataRequestBody, reqEditors ...RequestEditorFn) (*ObtainNewAccessrefreshTokenPairResponse, error) {
	rsp, err := c.ObtainNewAccessrefreshTokenPairWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObtainNewAccessrefreshTokenPairResponse(rsp)
}

// GetANewAccessTokenWithBodyWithResponse request with arbitrary body returning *GetANewAccessTokenResponse
func (c *ClientWithResponses) GetANewAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetANewAccessTokenResponse, error) {
	rsp, err := c.GetANewAccessTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetANewAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) GetANewAccessTokenWithResponse(ctx context.Context, body GetANewAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*GetANewAccessTokenResponse, error) {
	rsp, err := c.GetANewAccessToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetANewAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) GetANewAccessTokenWithFormdataBodyWithResponse(ctx context.Context, body GetANewAccessTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*GetANewAccessTokenResponse, error) {
	rsp, err := c.GetANewAccessTokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetANewAccessTokenResponse(rsp)
}

// ParseRetrieveAccountTransactionsPremiumResponse parses an HTTP response from a RetrieveAccountTransactionsPremiumWithResponse call
func ParseRetrieveAccountTransactionsPremiumResponse(rsp *http.Response) (*RetrieveAccountTransactionsPremiumResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAccountTransactionsPremiumResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BankTransactionStatusSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRetrieveAccountMetadataResponse parses an HTTP response from a RetrieveAccountMetadataWithResponse call
func ParseRetrieveAccountMetadataResponse(rsp *http.Response) (*RetrieveAccountMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAccountMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Account
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseRetrieveAccountBalancesResponse parses an HTTP response from a RetrieveAccountBalancesWithResponse call
func ParseRetrieveAccountBalancesResponse(rsp *http.Response) (*RetrieveAccountBalancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAccountBalancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountBalanceSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRetrieveAccountDetailsResponse parses an HTTP response from a RetrieveAccountDetailsWithResponse call
func ParseRetrieveAccountDetailsResponse(rsp *http.Response) (*RetrieveAccountDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAccountDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountDetailSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRetrieveAccountTransactionsResponse parses an HTTP response from a RetrieveAccountTransactionsWithResponse call
func ParseRetrieveAccountTransactionsResponse(rsp *http.Response) (*RetrieveAccountTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAccountTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BankTransactionStatusSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRetrieveAllEUAsForAnEndUserResponse parses an HTTP response from a RetrieveAllEUAsForAnEndUserWithResponse call
func ParseRetrieveAllEUAsForAnEndUserResponse(rsp *http.Response) (*RetrieveAllEUAsForAnEndUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAllEUAsForAnEndUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedEndUserAgreementList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseCreateEUAResponse parses an HTTP response from a CreateEUAWithResponse call
func ParseCreateEUAResponse(rsp *http.Response) (*CreateEUAResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEUAResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EndUserAgreement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeleteEUAByIdResponse parses an HTTP response from a DeleteEUAByIdWithResponse call
func ParseDeleteEUAByIdResponse(rsp *http.Response) (*DeleteEUAByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEUAByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseRetrieveEUAByIdResponse parses an HTTP response from a RetrieveEUAByIdWithResponse call
func ParseRetrieveEUAByIdResponse(rsp *http.Response) (*RetrieveEUAByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveEUAByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndUserAgreement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseAcceptEUAResponse parses an HTTP response from a AcceptEUAWithResponse call
func ParseAcceptEUAResponse(rsp *http.Response) (*AcceptEUAResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptEUAResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndUserAgreement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseRetrieveAllSupportedInstitutionsInAGivenCountryResponse parses an HTTP response from a RetrieveAllSupportedInstitutionsInAGivenCountryWithResponse call
func ParseRetrieveAllSupportedInstitutionsInAGivenCountryResponse(rsp *http.Response) (*RetrieveAllSupportedInstitutionsInAGivenCountryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAllSupportedInstitutionsInAGivenCountryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Integration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseRetrieveInstitutionResponse parses an HTTP response from a RetrieveInstitutionWithResponse call
func ParseRetrieveInstitutionResponse(rsp *http.Response) (*RetrieveInstitutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveInstitutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationRetrieve
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseRetrieveAllRequisitionsResponse parses an HTTP response from a RetrieveAllRequisitionsWithResponse call
func ParseRetrieveAllRequisitionsResponse(rsp *http.Response) (*RetrieveAllRequisitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAllRequisitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedRequisitionList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseCreateRequisitionResponse parses an HTTP response from a CreateRequisitionWithResponse call
func ParseCreateRequisitionResponse(rsp *http.Response) (*CreateRequisitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRequisitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpectacularRequisition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeleteRequisitionByIdResponse parses an HTTP response from a DeleteRequisitionByIdWithResponse call
func ParseDeleteRequisitionByIdResponse(rsp *http.Response) (*DeleteRequisitionByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRequisitionByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseRequisitionByIdResponse parses an HTTP response from a RequisitionByIdWithResponse call
func ParseRequisitionByIdResponse(rsp *http.Response) (*RequisitionByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequisitionByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Requisition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseObtainNewAccessrefreshTokenPairResponse parses an HTTP response from a ObtainNewAccessrefreshTokenPairWithResponse call
func ParseObtainNewAccessrefreshTokenPairResponse(rsp *http.Response) (*ObtainNewAccessrefreshTokenPairResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ObtainNewAccessrefreshTokenPairResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpectacularJWTObtain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetANewAccessTokenResponse parses an HTTP response from a GetANewAccessTokenWithResponse call
func ParseGetANewAccessTokenResponse(rsp *http.Response) (*GetANewAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetANewAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpectacularJWTRefresh
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /api/v2/accounts/premium/{id}/transactions/)
	RetrieveAccountTransactionsPremium(ctx echo.Context, id openapi_types.UUID, params RetrieveAccountTransactionsPremiumParams) error

	// (GET /api/v2/accounts/{id}/)
	RetrieveAccountMetadata(ctx echo.Context, id openapi_types.UUID) error

	// (GET /api/v2/accounts/{id}/balances/)
	RetrieveAccountBalances(ctx echo.Context, id openapi_types.UUID) error

	// (GET /api/v2/accounts/{id}/details/)
	RetrieveAccountDetails(ctx echo.Context, id openapi_types.UUID) error

	// (GET /api/v2/accounts/{id}/transactions/)
	RetrieveAccountTransactions(ctx echo.Context, id openapi_types.UUID, params RetrieveAccountTransactionsParams) error

	// (GET /api/v2/agreements/enduser/)
	RetrieveAllEUAsForAnEndUser(ctx echo.Context, params RetrieveAllEUAsForAnEndUserParams) error

	// (POST /api/v2/agreements/enduser/)
	CreateEUA(ctx echo.Context) error

	// (DELETE /api/v2/agreements/enduser/{id}/)
	DeleteEUAById(ctx echo.Context, id openapi_types.UUID) error

	// (GET /api/v2/agreements/enduser/{id}/)
	RetrieveEUAById(ctx echo.Context, id openapi_types.UUID) error

	// (PUT /api/v2/agreements/enduser/{id}/accept/)
	AcceptEUA(ctx echo.Context, id openapi_types.UUID) error

	// (GET /api/v2/institutions/)
	RetrieveAllSupportedInstitutionsInAGivenCountry(ctx echo.Context, params RetrieveAllSupportedInstitutionsInAGivenCountryParams) error

	// (GET /api/v2/institutions/{id}/)
	RetrieveInstitution(ctx echo.Context, id string) error

	// (GET /api/v2/requisitions/)
	RetrieveAllRequisitions(ctx echo.Context, params RetrieveAllRequisitionsParams) error

	// (POST /api/v2/requisitions/)
	CreateRequisition(ctx echo.Context) error

	// (DELETE /api/v2/requisitions/{id}/)
	DeleteRequisitionById(ctx echo.Context, id openapi_types.UUID) error

	// (GET /api/v2/requisitions/{id}/)
	RequisitionById(ctx echo.Context, id openapi_types.UUID) error

	// (POST /api/v2/token/new/)
	ObtainNewAccessrefreshTokenPair(ctx echo.Context) error

	// (POST /api/v2/token/refresh/)
	GetANewAccessToken(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// RetrieveAccountTransactionsPremium converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveAccountTransactionsPremium(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params RetrieveAccountTransactionsPremiumParams
	// ------------- Optional query parameter "country" -------------

	err = runtime.BindQueryParameter("form", true, false, "country", ctx.QueryParams(), &params.Country)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter country: %s", err))
	}

	// ------------- Optional query parameter "date_from" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_from", ctx.QueryParams(), &params.DateFrom)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date_from: %s", err))
	}

	// ------------- Optional query parameter "date_to" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_to", ctx.QueryParams(), &params.DateTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date_to: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveAccountTransactionsPremium(ctx, id, params)
	return err
}

// RetrieveAccountMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveAccountMetadata(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveAccountMetadata(ctx, id)
	return err
}

// RetrieveAccountBalances converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveAccountBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveAccountBalances(ctx, id)
	return err
}

// RetrieveAccountDetails converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveAccountDetails(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveAccountDetails(ctx, id)
	return err
}

// RetrieveAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params RetrieveAccountTransactionsParams
	// ------------- Optional query parameter "date_from" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_from", ctx.QueryParams(), &params.DateFrom)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date_from: %s", err))
	}

	// ------------- Optional query parameter "date_to" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_to", ctx.QueryParams(), &params.DateTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date_to: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveAccountTransactions(ctx, id, params)
	return err
}

// RetrieveAllEUAsForAnEndUser converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveAllEUAsForAnEndUser(ctx echo.Context) error {
	var err error

	ctx.Set(JwtAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params RetrieveAllEUAsForAnEndUserParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveAllEUAsForAnEndUser(ctx, params)
	return err
}

// CreateEUA converts echo context to params.
func (w *ServerInterfaceWrapper) CreateEUA(ctx echo.Context) error {
	var err error

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateEUA(ctx)
	return err
}

// DeleteEUAById converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEUAById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteEUAById(ctx, id)
	return err
}

// RetrieveEUAById converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveEUAById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveEUAById(ctx, id)
	return err
}

// AcceptEUA converts echo context to params.
func (w *ServerInterfaceWrapper) AcceptEUA(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AcceptEUA(ctx, id)
	return err
}

// RetrieveAllSupportedInstitutionsInAGivenCountry converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveAllSupportedInstitutionsInAGivenCountry(ctx echo.Context) error {
	var err error

	ctx.Set(JwtAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params RetrieveAllSupportedInstitutionsInAGivenCountryParams
	// ------------- Optional query parameter "access_scopes_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "access_scopes_supported", ctx.QueryParams(), &params.AccessScopesSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter access_scopes_supported: %s", err))
	}

	// ------------- Optional query parameter "account_selection_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "account_selection_supported", ctx.QueryParams(), &params.AccountSelectionSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account_selection_supported: %s", err))
	}

	// ------------- Optional query parameter "business_accounts_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "business_accounts_supported", ctx.QueryParams(), &params.BusinessAccountsSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter business_accounts_supported: %s", err))
	}

	// ------------- Optional query parameter "card_accounts_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "card_accounts_supported", ctx.QueryParams(), &params.CardAccountsSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter card_accounts_supported: %s", err))
	}

	// ------------- Optional query parameter "corporate_accounts_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "corporate_accounts_supported", ctx.QueryParams(), &params.CorporateAccountsSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter corporate_accounts_supported: %s", err))
	}

	// ------------- Optional query parameter "country" -------------

	err = runtime.BindQueryParameter("form", true, false, "country", ctx.QueryParams(), &params.Country)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter country: %s", err))
	}

	// ------------- Optional query parameter "payment_submission_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "payment_submission_supported", ctx.QueryParams(), &params.PaymentSubmissionSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_submission_supported: %s", err))
	}

	// ------------- Optional query parameter "payments_enabled" -------------

	err = runtime.BindQueryParameter("form", true, false, "payments_enabled", ctx.QueryParams(), &params.PaymentsEnabled)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payments_enabled: %s", err))
	}

	// ------------- Optional query parameter "pending_transactions_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "pending_transactions_supported", ctx.QueryParams(), &params.PendingTransactionsSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pending_transactions_supported: %s", err))
	}

	// ------------- Optional query parameter "private_accounts_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "private_accounts_supported", ctx.QueryParams(), &params.PrivateAccountsSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter private_accounts_supported: %s", err))
	}

	// ------------- Optional query parameter "read_refund_account_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "read_refund_account_supported", ctx.QueryParams(), &params.ReadRefundAccountSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter read_refund_account_supported: %s", err))
	}

	// ------------- Optional query parameter "ssn_verification_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "ssn_verification_supported", ctx.QueryParams(), &params.SsnVerificationSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ssn_verification_supported: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveAllSupportedInstitutionsInAGivenCountry(ctx, params)
	return err
}

// RetrieveInstitution converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveInstitution(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveInstitution(ctx, id)
	return err
}

// RetrieveAllRequisitions converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveAllRequisitions(ctx echo.Context) error {
	var err error

	ctx.Set(JwtAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params RetrieveAllRequisitionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveAllRequisitions(ctx, params)
	return err
}

// CreateRequisition converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRequisition(ctx echo.Context) error {
	var err error

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateRequisition(ctx)
	return err
}

// DeleteRequisitionById converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteRequisitionById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteRequisitionById(ctx, id)
	return err
}

// RequisitionById converts echo context to params.
func (w *ServerInterfaceWrapper) RequisitionById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RequisitionById(ctx, id)
	return err
}

// ObtainNewAccessrefreshTokenPair converts echo context to params.
func (w *ServerInterfaceWrapper) ObtainNewAccessrefreshTokenPair(ctx echo.Context) error {
	var err error

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ObtainNewAccessrefreshTokenPair(ctx)
	return err
}

// GetANewAccessToken converts echo context to params.
func (w *ServerInterfaceWrapper) GetANewAccessToken(ctx echo.Context) error {
	var err error

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetANewAccessToken(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v2/accounts/premium/:id/transactions/", wrapper.RetrieveAccountTransactionsPremium)
	router.GET(baseURL+"/api/v2/accounts/:id/", wrapper.RetrieveAccountMetadata)
	router.GET(baseURL+"/api/v2/accounts/:id/balances/", wrapper.RetrieveAccountBalances)
	router.GET(baseURL+"/api/v2/accounts/:id/details/", wrapper.RetrieveAccountDetails)
	router.GET(baseURL+"/api/v2/accounts/:id/transactions/", wrapper.RetrieveAccountTransactions)
	router.GET(baseURL+"/api/v2/agreements/enduser/", wrapper.RetrieveAllEUAsForAnEndUser)
	router.POST(baseURL+"/api/v2/agreements/enduser/", wrapper.CreateEUA)
	router.DELETE(baseURL+"/api/v2/agreements/enduser/:id/", wrapper.DeleteEUAById)
	router.GET(baseURL+"/api/v2/agreements/enduser/:id/", wrapper.RetrieveEUAById)
	router.PUT(baseURL+"/api/v2/agreements/enduser/:id/accept/", wrapper.AcceptEUA)
	router.GET(baseURL+"/api/v2/institutions/", wrapper.RetrieveAllSupportedInstitutionsInAGivenCountry)
	router.GET(baseURL+"/api/v2/institutions/:id/", wrapper.RetrieveInstitution)
	router.GET(baseURL+"/api/v2/requisitions/", wrapper.RetrieveAllRequisitions)
	router.POST(baseURL+"/api/v2/requisitions/", wrapper.CreateRequisition)
	router.DELETE(baseURL+"/api/v2/requisitions/:id/", wrapper.DeleteRequisitionById)
	router.GET(baseURL+"/api/v2/requisitions/:id/", wrapper.RequisitionById)
	router.POST(baseURL+"/api/v2/token/new/", wrapper.ObtainNewAccessrefreshTokenPair)
	router.POST(baseURL+"/api/v2/token/refresh/", wrapper.GetANewAccessToken)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
