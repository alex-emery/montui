// Package nordigen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.4 DO NOT EDIT.
package nordigen

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	JwtAuthScopes = "jwtAuth.Scopes"
)

// Defines values for AccountStatusEnum.
const (
	DISCOVERED AccountStatusEnum = "DISCOVERED"
	ERROR      AccountStatusEnum = "ERROR"
	PROCESSING AccountStatusEnum = "PROCESSING"
	READY      AccountStatusEnum = "READY"
	SUSPENDED  AccountStatusEnum = "SUSPENDED"
)

// Defines values for Status1c5Enum.
const (
	CR Status1c5Enum = "CR"
	ER Status1c5Enum = "ER"
	EX Status1c5Enum = "EX"
	GA Status1c5Enum = "GA"
	GC Status1c5Enum = "GC"
	ID Status1c5Enum = "ID"
	LN Status1c5Enum = "LN"
	RJ Status1c5Enum = "RJ"
	SA Status1c5Enum = "SA"
	SU Status1c5Enum = "SU"
	UA Status1c5Enum = "UA"
)

// Account The representation of a bank account.
type Account struct {
	// Created The date & time at which the account object was created.
	Created *time.Time `json:"created,omitempty"`

	// Iban The Account IBAN
	Iban *string `json:"iban,omitempty"`

	// ID The ID of this Account, used to refer to this account in other API calls.
	ID *openapi_types.UUID `json:"id,omitempty"`

	// InstitutionID The ASPSP associated with this account.
	InstitutionID *string `json:"institution_id,omitempty"`

	// LastAccessed The date & time at which the account object was last accessed.
	LastAccessed *time.Time `json:"last_accessed"`

	// OwnerName The name of the account owner.
	OwnerName *string `json:"owner_name,omitempty"`

	// Status The processing status of this account.
	Status *AccountStatusEnum `json:"status,omitempty"`
}

// AccountBalanceSchema defines model for AccountBalanceSchema.
type AccountBalanceSchema struct {
	Balances *[]BalanceSchema `json:"balances,omitempty"`
}

// AccountDetailSchema defines model for AccountDetailSchema.
type AccountDetailSchema struct {
	// Account account
	Account DetailSchema `json:"account"`
}

// AccountSchema defines model for AccountSchema.
type AccountSchema struct {
	// Bban bban
	Bban *string `json:"bban,omitempty"`

	// Currency currency
	Currency *string `json:"currency,omitempty"`

	// Iban iban
	Iban *string `json:"iban,omitempty"`

	// MaskedPan maskedPan
	MaskedPan *string `json:"maskedPan,omitempty"`

	// Msisdn msisdn
	Msisdn *string `json:"msisdn,omitempty"`

	// Pan pan
	Pan *string `json:"pan,omitempty"`
}

// AccountStatusEnum defines model for AccountStatusEnum.
type AccountStatusEnum string

// BalanceAmountSchema defines model for BalanceAmountSchema.
type BalanceAmountSchema struct {
	// Amount amount
	Amount string `json:"amount"`

	// Currency currency
	Currency string `json:"currency"`
}

// BalanceSchema defines model for BalanceSchema.
type BalanceSchema struct {
	// BalanceAmount balanceAmount
	BalanceAmount BalanceAmountSchema `json:"balanceAmount"`

	// BalanceType balanceType
	BalanceType string `json:"balanceType"`

	// CreditLimitIncluded creditLimitIncluded
	CreditLimitIncluded *bool `json:"creditLimitIncluded,omitempty"`

	// LastChangeDateTime lastChangeDateTime
	LastChangeDateTime *string `json:"lastChangeDateTime,omitempty"`

	// LastCommittedTransaction lastCommittedTransaction
	LastCommittedTransaction *string `json:"lastCommittedTransaction,omitempty"`

	// ReferenceDate referenceDate
	ReferenceDate *string `json:"referenceDate,omitempty"`
}

// BankTransactionStatusSchema defines model for BankTransactionStatusSchema.
type BankTransactionStatusSchema struct {
	Booked  []TransactionSchema  `json:"booked"`
	Pending *[]TransactionSchema `json:"pending,omitempty"`
}

// CurrencyExchangeSchema defines model for CurrencyExchangeSchema.
type CurrencyExchangeSchema struct {
	// ContractIDentification contractIDentification
	ContractIDentification *string `json:"contractIDentification,omitempty"`

	// ExchangeRate exchangeRate
	ExchangeRate *string `json:"exchangeRate,omitempty"`

	// QuotationDate quotationDate
	QuotationDate *string `json:"quotationDate,omitempty"`

	// SourceCurrency sourceCurrency
	SourceCurrency *string `json:"sourceCurrency,omitempty"`

	// TargetCurrency targetCurrency
	TargetCurrency *string `json:"targetCurrency,omitempty"`

	// UnitCurrency unitCurrency
	UnitCurrency *string `json:"unitCurrency,omitempty"`
}

// DetailSchema defines model for DetailSchema.
type DetailSchema struct {
	// Bban bban
	Bban *string `json:"bban,omitempty"`

	// Bic bic
	Bic *string `json:"bic,omitempty"`

	// CashAccountType cashAccountType
	CashAccountType *string `json:"cashAccountType,omitempty"`

	// Currency currency
	Currency *string `json:"currency,omitempty"`

	// Details details
	Details *string `json:"details,omitempty"`

	// DisplayName displayName
	DisplayName *string `json:"displayName,omitempty"`

	// Iban iban
	Iban *string `json:"iban,omitempty"`

	// LinkedAccounts linkedAccounts
	LinkedAccounts *string `json:"linkedAccounts,omitempty"`

	// MaskedPan maskedPan
	MaskedPan *string `json:"maskedPan,omitempty"`

	// Msisdn msisdn
	Msisdn *string `json:"msisdn,omitempty"`

	// Name name
	Name *string `json:"name,omitempty"`

	// OwnerAddressStructured ownerAddressStructured
	OwnerAddressStructured *OwnerAddressStructuredSchema `json:"ownerAddressStructured,omitempty"`

	// OwnerAddressUnstructured ownerAddressUnstructured
	OwnerAddressUnstructured *[]string `json:"ownerAddressUnstructured,omitempty"`

	// OwnerName ownerName
	OwnerName *string `json:"ownerName,omitempty"`

	// Product product
	Product *string `json:"product,omitempty"`

	// ResourceID resourceID
	ResourceID *string `json:"resourceID,omitempty"`

	// Status status
	Status *string `json:"status,omitempty"`

	// Usage usage
	Usage *string `json:"usage,omitempty"`
}

// EndUserAgreement Represents an end-user agreement.
type EndUserAgreement struct {
	// Accepted The date & time at which the end user accepted the agreement.
	Accepted *time.Time `json:"accepted"`

	// AccessScope Array containing one or several values of ['balances', 'details', 'transactions']
	AccessScope *[]interface{} `json:"access_scope,omitempty"`

	// AccessValidForDays Number of days from acceptance that the access can be used.
	AccessValidForDays *int `json:"access_valid_for_days,omitempty"`

	// Created The date & time at which the end user agreement was created.
	Created *time.Time `json:"created,omitempty"`

	// ID The ID of this End User Agreement, used to refer to this end user agreement in other API calls.
	ID *openapi_types.UUID `json:"id,omitempty"`

	// InstitutionID an Institution ID for this EUA
	InstitutionID string `json:"institution_id"`

	// MaxHistoricalDays Maximum number of days of transaction data to retrieve.
	MaxHistoricalDays *int `json:"max_historical_days,omitempty"`
}

// EndUserAgreementRequest Represents an end-user agreement.
type EndUserAgreementRequest struct {
	// AccessScope Array containing one or several values of ['balances', 'details', 'transactions']
	AccessScope *[]interface{} `json:"access_scope,omitempty"`

	// AccessValidForDays Number of days from acceptance that the access can be used.
	AccessValidForDays *int `json:"access_valid_for_days,omitempty"`

	// InstitutionID an Institution ID for this EUA
	InstitutionID string `json:"institution_id"`

	// MaxHistoricalDays Maximum number of days of transaction data to retrieve.
	MaxHistoricalDays *int `json:"max_historical_days,omitempty"`
}

// EnduserAcceptanceDetailsRequest Represents end-user details.
type EnduserAcceptanceDetailsRequest struct {
	IpAddress string `json:"ip_address"`
	UserAgent string `json:"user_agent"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Detail     string  `json:"detail"`
	StatusCode int     `json:"status_code"`
	Summary    string  `json:"summary"`
	Type       *string `json:"type,omitempty"`
}

// Integration Represents an Integration.
type Integration struct {
	Bic                  *string  `json:"bic,omitempty"`
	Countries            []string `json:"countries"`
	ID                   string   `json:"id"`
	Logo                 string   `json:"logo"`
	Name                 string   `json:"name"`
	TransactionTotalDays *string  `json:"transaction_total_days,omitempty"`
}

// IntegrationRetrieve IntegrationSerializer for Retrieve endpoint.
type IntegrationRetrieve struct {
	Bic                  *string                `json:"bic,omitempty"`
	Countries            []string               `json:"countries"`
	ID                   string                 `json:"id"`
	IDentificationCodes  []interface{}          `json:"identification_codes"`
	Logo                 string                 `json:"logo"`
	Name                 string                 `json:"name"`
	SupportedFeatures    []interface{}          `json:"supported_features"`
	SupportedPayments    map[string]interface{} `json:"supported_payments"`
	TransactionTotalDays *string                `json:"transaction_total_days,omitempty"`
}

// JWTObtainPairRequest Obtain JWT pair.
type JWTObtainPairRequest struct {
	// SecretID Secret id from /user-secrets/
	SecretID string `json:"secret_id"`

	// SecretKey Secret key from /user-secrets/
	SecretKey string `json:"secret_key"`
}

// JWTRefreshRequest Refresh access token.
type JWTRefreshRequest struct {
	Refresh string `json:"refresh"`
}

// OwnerAddressStructuredSchema defines model for OwnerAddressStructuredSchema.
type OwnerAddressStructuredSchema struct {
	// BuildingNumber buildingNumber
	BuildingNumber *string `json:"buildingNumber,omitempty"`

	// Country country
	Country *string `json:"country,omitempty"`

	// PostCode postCode
	PostCode *string `json:"postCode,omitempty"`

	// StreetName streetName
	StreetName *string `json:"streetName,omitempty"`

	// TownName townName
	TownName *string `json:"townName,omitempty"`
}

// PaginatedEndUserAgreementList defines model for PaginatedEndUserAgreementList.
type PaginatedEndUserAgreementList struct {
	Count    *int                `json:"count,omitempty"`
	Next     *string             `json:"next"`
	Previous *string             `json:"previous"`
	Results  *[]EndUserAgreement `json:"results,omitempty"`
}

// PaginatedRequisitionList defines model for PaginatedRequisitionList.
type PaginatedRequisitionList struct {
	Count    *int           `json:"count,omitempty"`
	Next     *string        `json:"next"`
	Previous *string        `json:"previous"`
	Results  *[]Requisition `json:"results,omitempty"`
}

// Requisition RequisitionSerializer.
type Requisition struct {
	// AccountSelection option to enable account selection view for the end user
	AccountSelection *bool `json:"account_selection,omitempty"`

	// Accounts array of account IDs retrieved within a scope of this requisition
	Accounts *[]openapi_types.UUID `json:"accounts,omitempty"`

	// Agreement EUA associated with this requisition
	Agreement *openapi_types.UUID `json:"agreement,omitempty"`

	// Created The date & time at which the requisition was created.
	Created *time.Time          `json:"created"`
	ID      *openapi_types.UUID `json:"id,omitempty"`

	// InstitutionID an Institution ID for this Requisition
	InstitutionID string `json:"institution_id"`

	// Link link to initiate authorization with Institution
	Link *string `json:"link,omitempty"`

	// Redirect redirect URL to your application after end-user authorization with ASPSP
	Redirect *string `json:"redirect"`

	// RedirectImmediate enable redirect back to the client after account list received
	RedirectImmediate *bool `json:"redirect_immediate,omitempty"`

	// Reference additional ID to identify the end user
	Reference *string `json:"reference,omitempty"`

	// Ssn optional SSN field to verify ownership of the account
	Ssn *string `json:"ssn,omitempty"`

	// Status status of this requisition
	Status *Status1c5Enum `json:"status,omitempty"`

	// UserLanguage A two-letter country code (ISO 639-1)
	UserLanguage *string `json:"user_language,omitempty"`
}

// RequisitionRequest RequisitionSerializer.
type RequisitionRequest struct {
	// AccountSelection option to enable account selection view for the end user
	AccountSelection *bool `json:"account_selection,omitempty"`

	// Agreement EUA associated with this requisition
	Agreement *openapi_types.UUID `json:"agreement,omitempty"`

	// InstitutionID an Institution ID for this Requisition
	InstitutionID string `json:"institution_id"`

	// Redirect redirect URL to your application after end-user authorization with ASPSP
	Redirect *string `json:"redirect"`

	// RedirectImmediate enable redirect back to the client after account list received
	RedirectImmediate *bool `json:"redirect_immediate,omitempty"`

	// Reference additional ID to identify the end user
	Reference *string `json:"reference,omitempty"`

	// Ssn optional SSN field to verify ownership of the account
	Ssn *string `json:"ssn,omitempty"`

	// UserLanguage A two-letter country code (ISO 639-1)
	UserLanguage *string `json:"user_language,omitempty"`
}

// SpectacularJWTObtain Obtain new JWT pair.
type SpectacularJWTObtain struct {
	// Access Your access token
	Access *string `json:"access,omitempty"`

	// AccessExpires Access token expires in seconds
	AccessExpires *int `json:"access_expires,omitempty"`

	// Refresh Your refresh token
	Refresh *string `json:"refresh,omitempty"`

	// RefreshExpires Refresh token expires in seconds
	RefreshExpires *int `json:"refresh_expires,omitempty"`
}

// SpectacularJWTRefresh Refresh Access token.
type SpectacularJWTRefresh struct {
	// Access Your access token
	Access *string `json:"access,omitempty"`

	// AccessExpires Access token expires in seconds
	AccessExpires *int `json:"access_expires,omitempty"`
}

// SpectacularRequisition Create requisition.
type SpectacularRequisition struct {
	// AccountSelection option to enable account selection view for the end user
	AccountSelection *bool `json:"account_selection,omitempty"`

	// Accounts array of account IDs retrieved within a scope of this requisition
	Accounts *[]interface{} `json:"accounts,omitempty"`

	// Agreement EUA associated with this requisition
	// Agreement *openapi_types.UUID `json:"agreement,omitempty"` // Commented out because it can be empty string

	// Created The date & time at which the requisition was created.
	Created *time.Time          `json:"created"`
	ID      *openapi_types.UUID `json:"id,omitempty"`

	// InstitutionID an Institution ID for this Requisition
	InstitutionID string `json:"institution_id"`

	// Link link to initiate authorization with Institution
	Link *string `json:"link,omitempty"`

	// Redirect redirect URL to your application after end-user authorization with ASPSP
	Redirect *string `json:"redirect"`

	// RedirectImmediate enable redirect back to the client after account list received
	RedirectImmediate *bool `json:"redirect_immediate,omitempty"`

	// Reference additional ID to identify the end user
	Reference *string `json:"reference,omitempty"`

	// Ssn optional SSN field to verify ownership of the account
	Ssn *string `json:"ssn,omitempty"`

	// Status status of this requisition
	Status *Status1c5Enum `json:"status,omitempty"`

	// UserLanguage A two-letter country code (ISO 639-1)
	UserLanguage *string `json:"user_language,omitempty"`
}

// Status1c5Enum defines model for Status1c5Enum.
type Status1c5Enum string

// TransactionAmountSchema defines model for TransactionAmountSchema.
type TransactionAmountSchema struct {
	// Amount amount
	Amount string `json:"amount"`

	// Currency currency
	Currency string `json:"currency"`
}

// TransactionSchema defines model for TransactionSchema.
type TransactionSchema struct {
	// AdditionalInformation additionalInformation
	AdditionalInformation *string `json:"additionalInformation,omitempty"`

	// BankTransactionCode bankTransactionCode
	BankTransactionCode *string `json:"bankTransactionCode,omitempty"`

	// BookingDate bookingDate
	BookingDate *string `json:"bookingDate,omitempty"`

	// BookingDateTime bookingDateTime
	BookingDateTime *string `json:"bookingDateTime,omitempty"`

	// CheckID checkID
	CheckID *string `json:"checkID,omitempty"`

	// CreditorAccount creditorAccount
	CreditorAccount *AccountSchema `json:"creditorAccount,omitempty"`

	// CreditorID creditorID
	CreditorID *string `json:"creditorID,omitempty"`

	// CreditorName creditorName
	CreditorName *string `json:"creditorName,omitempty"`

	// CurrencyExchange currencyExchange
	CurrencyExchange *CurrencyExchangeSchema `json:"currencyExchange,omitempty"`

	// DebtorAccount debtorAccount
	DebtorAccount *AccountSchema `json:"debtorAccount,omitempty"`

	// DebtorName debtorName
	DebtorName *string `json:"debtorName,omitempty"`

	// EndToEndID endToEndID
	EndToEndID *string `json:"endToEndID,omitempty"`

	// EntryReference entryReference
	EntryReference *string `json:"entryReference,omitempty"`

	// InternalTransactionID internalTransactionID
	InternalTransactionID *string `json:"internalTransactionID,omitempty"`

	// MandateID mandateID
	MandateID *string `json:"mandateID,omitempty"`

	// MerchantCategoryCode merchantCategoryCode
	MerchantCategoryCode *string `json:"merchantCategoryCode,omitempty"`

	// ProprietaryBankTransactionCode proprietaryBankTransactionCode
	ProprietaryBankTransactionCode *string `json:"proprietaryBankTransactionCode,omitempty"`

	// PurposeCode purposeCode
	PurposeCode *string `json:"purposeCode,omitempty"`

	// RemittanceInformationStructured remittanceInformationStructured
	RemittanceInformationStructured *string `json:"remittanceInformationStructured,omitempty"`

	// RemittanceInformationStructuredArray remittanceInformationStructuredArray
	RemittanceInformationStructuredArray *[]string `json:"remittanceInformationStructuredArray,omitempty"`

	// RemittanceInformationUnstructured remittanceInformationUnstructured
	RemittanceInformationUnstructured *string `json:"remittanceInformationUnstructured,omitempty"`

	// RemittanceInformationUnstructuredArray remittanceInformationUnstructuredArray
	RemittanceInformationUnstructuredArray *[]string `json:"remittanceInformationUnstructuredArray,omitempty"`

	// TransactionAmount transactionAmount
	TransactionAmount TransactionAmountSchema `json:"transactionAmount"`

	// TransactionID transactionID
	TransactionID *string `json:"transactionID,omitempty"`

	// UltimateCreditor ultimateCreditor
	UltimateCreditor *string `json:"ultimateCreditor,omitempty"`

	// UltimateDebtor ultimateDebtor
	UltimateDebtor *string `json:"ultimateDebtor,omitempty"`

	// ValueDate valueDate
	ValueDate *string `json:"valueDate,omitempty"`

	// ValueDateTime valueDateTime
	ValueDateTime *string `json:"valueDateTime,omitempty"`
}

// RetrieveAccountTransactionsPremiumParams defines parameters for RetrieveAccountTransactionsPremium.
type RetrieveAccountTransactionsPremiumParams struct {
	// Country ISO 3166 two-character country code
	Country  *string             `form:"country,omitempty" json:"country,omitempty"`
	DateFrom *openapi_types.Date `form:"date_from,omitempty" json:"date_from,omitempty"`
	DateTo   *openapi_types.Date `form:"date_to,omitempty" json:"date_to,omitempty"`
}

// RetrieveAccountTransactionsParams defines parameters for RetrieveAccountTransactions.
type RetrieveAccountTransactionsParams struct {
	DateFrom *openapi_types.Date `form:"date_from,omitempty" json:"date_from,omitempty"`
	DateTo   *openapi_types.Date `form:"date_to,omitempty" json:"date_to,omitempty"`
}

// RetrieveAllEUAsForAnEndUserParams defines parameters for RetrieveAllEUAsForAnEndUser.
type RetrieveAllEUAsForAnEndUserParams struct {
	// Limit Number of results to return per page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The initial index from which to return the results.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// RetrieveAllSupportedInstitutionsInAGivenCountryParams defines parameters for RetrieveAllSupportedInstitutionsInAGivenCountry.
type RetrieveAllSupportedInstitutionsInAGivenCountryParams struct {
	// AccessScopesSupported Boolean value, indicating if access scopes are supported
	AccessScopesSupported *string `form:"access_scopes_supported,omitempty" json:"access_scopes_supported,omitempty"`

	// AccountSelectionSupported Boolean value, indicating if account selection is supported
	AccountSelectionSupported *string `form:"account_selection_supported,omitempty" json:"account_selection_supported,omitempty"`

	// BusinessAccountsSupported Boolean value, indicating if business accounts are supported
	BusinessAccountsSupported *string `form:"business_accounts_supported,omitempty" json:"business_accounts_supported,omitempty"`

	// CardAccountsSupported Boolean value, indicating if card accounts are supported
	CardAccountsSupported *string `form:"card_accounts_supported,omitempty" json:"card_accounts_supported,omitempty"`

	// CorporateAccountsSupported Boolean value, indicating if corporate accounts are supported
	CorporateAccountsSupported *string `form:"corporate_accounts_supported,omitempty" json:"corporate_accounts_supported,omitempty"`

	// Country ISO 3166 two-character country code
	Country *string `form:"country,omitempty" json:"country,omitempty"`

	// PaymentSubmissionSupported Boolean value, indicating if payment submission is supported
	PaymentSubmissionSupported *string `form:"payment_submission_supported,omitempty" json:"payment_submission_supported,omitempty"`

	// PaymentsEnabled Boolean value, indicating if payments are supported
	PaymentsEnabled *string `form:"payments_enabled,omitempty" json:"payments_enabled,omitempty"`

	// PendingTransactionsSupported Boolean value, indicating if pending transactions are supported
	PendingTransactionsSupported *string `form:"pending_transactions_supported,omitempty" json:"pending_transactions_supported,omitempty"`

	// PrivateAccountsSupported Boolean value, indicating if private accounts are supported
	PrivateAccountsSupported *string `form:"private_accounts_supported,omitempty" json:"private_accounts_supported,omitempty"`

	// ReadRefundAccountSupported Boolean value, indicating if read refund account is supported
	ReadRefundAccountSupported *string `form:"read_refund_account_supported,omitempty" json:"read_refund_account_supported,omitempty"`

	// SsnVerificationSupported Boolean value, indicating if ssn verification is supported
	SsnVerificationSupported *string `form:"ssn_verification_supported,omitempty" json:"ssn_verification_supported,omitempty"`
}

// RetrieveAllRequisitionsParams defines parameters for RetrieveAllRequisitions.
type RetrieveAllRequisitionsParams struct {
	// Limit Number of results to return per page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The initial index from which to return the results.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// CreateEUAJSONRequestBody defines body for CreateEUA for application/json ContentType.
type CreateEUAJSONRequestBody = EndUserAgreementRequest

// CreateEUAFormdataRequestBody defines body for CreateEUA for application/x-www-form-urlencoded ContentType.
type CreateEUAFormdataRequestBody = EndUserAgreementRequest

// CreateEUAMultipartRequestBody defines body for CreateEUA for multipart/form-data ContentType.
type CreateEUAMultipartRequestBody = EndUserAgreementRequest

// AcceptEUAJSONRequestBody defines body for AcceptEUA for application/json ContentType.
type AcceptEUAJSONRequestBody = EnduserAcceptanceDetailsRequest

// AcceptEUAFormdataRequestBody defines body for AcceptEUA for application/x-www-form-urlencoded ContentType.
type AcceptEUAFormdataRequestBody = EnduserAcceptanceDetailsRequest

// AcceptEUAMultipartRequestBody defines body for AcceptEUA for multipart/form-data ContentType.
type AcceptEUAMultipartRequestBody = EnduserAcceptanceDetailsRequest

// CreateRequisitionJSONRequestBody defines body for CreateRequisition for application/json ContentType.
type CreateRequisitionJSONRequestBody = RequisitionRequest

// CreateRequisitionFormdataRequestBody defines body for CreateRequisition for application/x-www-form-urlencoded ContentType.
type CreateRequisitionFormdataRequestBody = RequisitionRequest

// CreateRequisitionMultipartRequestBody defines body for CreateRequisition for multipart/form-data ContentType.
type CreateRequisitionMultipartRequestBody = RequisitionRequest

// ObtainNewAccessrefreshTokenPairJSONRequestBody defines body for ObtainNewAccessrefreshTokenPair for application/json ContentType.
type ObtainNewAccessrefreshTokenPairJSONRequestBody = JWTObtainPairRequest

// ObtainNewAccessrefreshTokenPairFormdataRequestBody defines body for ObtainNewAccessrefreshTokenPair for application/x-www-form-urlencoded ContentType.
type ObtainNewAccessrefreshTokenPairFormdataRequestBody = JWTObtainPairRequest

// ObtainNewAccessrefreshTokenPairMultipartRequestBody defines body for ObtainNewAccessrefreshTokenPair for multipart/form-data ContentType.
type ObtainNewAccessrefreshTokenPairMultipartRequestBody = JWTObtainPairRequest

// GetANewAccessTokenJSONRequestBody defines body for GetANewAccessToken for application/json ContentType.
type GetANewAccessTokenJSONRequestBody = JWTRefreshRequest

// GetANewAccessTokenFormdataRequestBody defines body for GetANewAccessToken for application/x-www-form-urlencoded ContentType.
type GetANewAccessTokenFormdataRequestBody = JWTRefreshRequest

// GetANewAccessTokenMultipartRequestBody defines body for GetANewAccessToken for multipart/form-data ContentType.
type GetANewAccessTokenMultipartRequestBody = JWTRefreshRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// RetrieveAccountTransactionsPremium request
	RetrieveAccountTransactionsPremium(ctx context.Context, id openapi_types.UUID, params *RetrieveAccountTransactionsPremiumParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAccountMetadata request
	RetrieveAccountMetadata(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAccountBalances request
	RetrieveAccountBalances(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAccountDetails request
	RetrieveAccountDetails(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAccountTransactions request
	RetrieveAccountTransactions(ctx context.Context, id openapi_types.UUID, params *RetrieveAccountTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAllEUAsForAnEndUser request
	RetrieveAllEUAsForAnEndUser(ctx context.Context, params *RetrieveAllEUAsForAnEndUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEUAWithBody request with any body
	CreateEUAWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEUA(ctx context.Context, body CreateEUAJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEUAWithFormdataBody(ctx context.Context, body CreateEUAFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEUAByID request
	DeleteEUAByID(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveEUAByID request
	RetrieveEUAByID(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptEUAWithBody request with any body
	AcceptEUAWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AcceptEUA(ctx context.Context, id openapi_types.UUID, body AcceptEUAJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	AcceptEUAWithFormdataBody(ctx context.Context, id openapi_types.UUID, body AcceptEUAFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAllSupportedInstitutionsInAGivenCountry request
	RetrieveAllSupportedInstitutionsInAGivenCountry(ctx context.Context, params *RetrieveAllSupportedInstitutionsInAGivenCountryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveInstitution request
	RetrieveInstitution(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAllRequisitions request
	RetrieveAllRequisitions(ctx context.Context, params *RetrieveAllRequisitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRequisitionWithBody request with any body
	CreateRequisitionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRequisition(ctx context.Context, body CreateRequisitionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRequisitionWithFormdataBody(ctx context.Context, body CreateRequisitionFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRequisitionByID request
	DeleteRequisitionByID(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequisitionByID request
	RequisitionByID(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ObtainNewAccessrefreshTokenPairWithBody request with any body
	ObtainNewAccessrefreshTokenPairWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ObtainNewAccessrefreshTokenPair(ctx context.Context, body ObtainNewAccessrefreshTokenPairJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	ObtainNewAccessrefreshTokenPairWithFormdataBody(ctx context.Context, body ObtainNewAccessrefreshTokenPairFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetANewAccessTokenWithBody request with any body
	GetANewAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetANewAccessToken(ctx context.Context, body GetANewAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetANewAccessTokenWithFormdataBody(ctx context.Context, body GetANewAccessTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) RetrieveAccountTransactionsPremium(ctx context.Context, id openapi_types.UUID, params *RetrieveAccountTransactionsPremiumParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAccountTransactionsPremiumRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAccountMetadata(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAccountMetadataRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAccountBalances(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAccountBalancesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAccountDetails(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAccountDetailsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAccountTransactions(ctx context.Context, id openapi_types.UUID, params *RetrieveAccountTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAccountTransactionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAllEUAsForAnEndUser(ctx context.Context, params *RetrieveAllEUAsForAnEndUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAllEUAsForAnEndUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEUAWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEUARequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEUA(ctx context.Context, body CreateEUAJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEUARequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEUAWithFormdataBody(ctx context.Context, body CreateEUAFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEUARequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEUAByID(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEUAByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveEUAByID(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveEUAByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptEUAWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptEUARequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptEUA(ctx context.Context, id openapi_types.UUID, body AcceptEUAJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptEUARequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptEUAWithFormdataBody(ctx context.Context, id openapi_types.UUID, body AcceptEUAFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptEUARequestWithFormdataBody(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAllSupportedInstitutionsInAGivenCountry(ctx context.Context, params *RetrieveAllSupportedInstitutionsInAGivenCountryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAllSupportedInstitutionsInAGivenCountryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveInstitution(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveInstitutionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAllRequisitions(ctx context.Context, params *RetrieveAllRequisitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAllRequisitionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRequisitionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequisitionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRequisition(ctx context.Context, body CreateRequisitionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequisitionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRequisitionWithFormdataBody(ctx context.Context, body CreateRequisitionFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequisitionRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRequisitionByID(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRequisitionByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequisitionByID(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequisitionByIDRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObtainNewAccessrefreshTokenPairWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObtainNewAccessrefreshTokenPairRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObtainNewAccessrefreshTokenPair(ctx context.Context, body ObtainNewAccessrefreshTokenPairJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObtainNewAccessrefreshTokenPairRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObtainNewAccessrefreshTokenPairWithFormdataBody(ctx context.Context, body ObtainNewAccessrefreshTokenPairFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObtainNewAccessrefreshTokenPairRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetANewAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetANewAccessTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetANewAccessToken(ctx context.Context, body GetANewAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetANewAccessTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetANewAccessTokenWithFormdataBody(ctx context.Context, body GetANewAccessTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetANewAccessTokenRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewRetrieveAccountTransactionsPremiumRequest generates requests for RetrieveAccountTransactionsPremium
func NewRetrieveAccountTransactionsPremiumRequest(server string, id openapi_types.UUID, params *RetrieveAccountTransactionsPremiumParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/accounts/premium/%s/transactions/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Country != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country", runtime.ParamLocationQuery, *params.Country); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_from", runtime.ParamLocationQuery, *params.DateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_to", runtime.ParamLocationQuery, *params.DateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveAccountMetadataRequest generates requests for RetrieveAccountMetadata
func NewRetrieveAccountMetadataRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/accounts/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveAccountBalancesRequest generates requests for RetrieveAccountBalances
func NewRetrieveAccountBalancesRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/accounts/%s/balances/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveAccountDetailsRequest generates requests for RetrieveAccountDetails
func NewRetrieveAccountDetailsRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/accounts/%s/details/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveAccountTransactionsRequest generates requests for RetrieveAccountTransactions
func NewRetrieveAccountTransactionsRequest(server string, id openapi_types.UUID, params *RetrieveAccountTransactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/accounts/%s/transactions/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_from", runtime.ParamLocationQuery, *params.DateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_to", runtime.ParamLocationQuery, *params.DateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveAllEUAsForAnEndUserRequest generates requests for RetrieveAllEUAsForAnEndUser
func NewRetrieveAllEUAsForAnEndUserRequest(server string, params *RetrieveAllEUAsForAnEndUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/agreements/enduser/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEUARequest calls the generic CreateEUA builder with application/json body
func NewCreateEUARequest(server string, body CreateEUAJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEUARequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEUARequestWithFormdataBody calls the generic CreateEUA builder with application/x-www-form-urlencoded body
func NewCreateEUARequestWithFormdataBody(server string, body CreateEUAFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewCreateEUARequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewCreateEUARequestWithBody generates requests for CreateEUA with any type of body
func NewCreateEUARequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/agreements/enduser/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEUAByIDRequest generates requests for DeleteEUAByID
func NewDeleteEUAByIDRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/agreements/enduser/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveEUAByIDRequest generates requests for RetrieveEUAByID
func NewRetrieveEUAByIDRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/agreements/enduser/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcceptEUARequest calls the generic AcceptEUA builder with application/json body
func NewAcceptEUARequest(server string, id openapi_types.UUID, body AcceptEUAJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAcceptEUARequestWithBody(server, id, "application/json", bodyReader)
}

// NewAcceptEUARequestWithFormdataBody calls the generic AcceptEUA builder with application/x-www-form-urlencoded body
func NewAcceptEUARequestWithFormdataBody(server string, id openapi_types.UUID, body AcceptEUAFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewAcceptEUARequestWithBody(server, id, "application/x-www-form-urlencoded", bodyReader)
}

// NewAcceptEUARequestWithBody generates requests for AcceptEUA with any type of body
func NewAcceptEUARequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/agreements/enduser/%s/accept/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRetrieveAllSupportedInstitutionsInAGivenCountryRequest generates requests for RetrieveAllSupportedInstitutionsInAGivenCountry
func NewRetrieveAllSupportedInstitutionsInAGivenCountryRequest(server string, params *RetrieveAllSupportedInstitutionsInAGivenCountryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/institutions/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AccessScopesSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_scopes_supported", runtime.ParamLocationQuery, *params.AccessScopesSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccountSelectionSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_selection_supported", runtime.ParamLocationQuery, *params.AccountSelectionSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BusinessAccountsSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "business_accounts_supported", runtime.ParamLocationQuery, *params.BusinessAccountsSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CardAccountsSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "card_accounts_supported", runtime.ParamLocationQuery, *params.CardAccountsSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CorporateAccountsSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "corporate_accounts_supported", runtime.ParamLocationQuery, *params.CorporateAccountsSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Country != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country", runtime.ParamLocationQuery, *params.Country); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaymentSubmissionSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payment_submission_supported", runtime.ParamLocationQuery, *params.PaymentSubmissionSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaymentsEnabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payments_enabled", runtime.ParamLocationQuery, *params.PaymentsEnabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PendingTransactionsSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pending_transactions_supported", runtime.ParamLocationQuery, *params.PendingTransactionsSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateAccountsSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "private_accounts_supported", runtime.ParamLocationQuery, *params.PrivateAccountsSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReadRefundAccountSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "read_refund_account_supported", runtime.ParamLocationQuery, *params.ReadRefundAccountSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SsnVerificationSupported != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ssn_verification_supported", runtime.ParamLocationQuery, *params.SsnVerificationSupported); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveInstitutionRequest generates requests for RetrieveInstitution
func NewRetrieveInstitutionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/institutions/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveAllRequisitionsRequest generates requests for RetrieveAllRequisitions
func NewRetrieveAllRequisitionsRequest(server string, params *RetrieveAllRequisitionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/requisitions/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRequisitionRequest calls the generic CreateRequisition builder with application/json body
func NewCreateRequisitionRequest(server string, body CreateRequisitionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRequisitionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRequisitionRequestWithFormdataBody calls the generic CreateRequisition builder with application/x-www-form-urlencoded body
func NewCreateRequisitionRequestWithFormdataBody(server string, body CreateRequisitionFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewCreateRequisitionRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewCreateRequisitionRequestWithBody generates requests for CreateRequisition with any type of body
func NewCreateRequisitionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/requisitions/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRequisitionByIDRequest generates requests for DeleteRequisitionByID
func NewDeleteRequisitionByIDRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/requisitions/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRequisitionByIDRequest generates requests for RequisitionByID
func NewRequisitionByIDRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/requisitions/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewObtainNewAccessrefreshTokenPairRequest calls the generic ObtainNewAccessrefreshTokenPair builder with application/json body
func NewObtainNewAccessrefreshTokenPairRequest(server string, body ObtainNewAccessrefreshTokenPairJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewObtainNewAccessrefreshTokenPairRequestWithBody(server, "application/json", bodyReader)
}

// NewObtainNewAccessrefreshTokenPairRequestWithFormdataBody calls the generic ObtainNewAccessrefreshTokenPair builder with application/x-www-form-urlencoded body
func NewObtainNewAccessrefreshTokenPairRequestWithFormdataBody(server string, body ObtainNewAccessrefreshTokenPairFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewObtainNewAccessrefreshTokenPairRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewObtainNewAccessrefreshTokenPairRequestWithBody generates requests for ObtainNewAccessrefreshTokenPair with any type of body
func NewObtainNewAccessrefreshTokenPairRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/token/new/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetANewAccessTokenRequest calls the generic GetANewAccessToken builder with application/json body
func NewGetANewAccessTokenRequest(server string, body GetANewAccessTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetANewAccessTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewGetANewAccessTokenRequestWithFormdataBody calls the generic GetANewAccessToken builder with application/x-www-form-urlencoded body
func NewGetANewAccessTokenRequestWithFormdataBody(server string, body GetANewAccessTokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewGetANewAccessTokenRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewGetANewAccessTokenRequestWithBody generates requests for GetANewAccessToken with any type of body
func NewGetANewAccessTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/token/refresh/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// RetrieveAccountTransactionsPremiumWithResponse request
	RetrieveAccountTransactionsPremiumWithResponse(ctx context.Context, id openapi_types.UUID, params *RetrieveAccountTransactionsPremiumParams, reqEditors ...RequestEditorFn) (*RetrieveAccountTransactionsPremiumResponse, error)

	// RetrieveAccountMetadataWithResponse request
	RetrieveAccountMetadataWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RetrieveAccountMetadataResponse, error)

	// RetrieveAccountBalancesWithResponse request
	RetrieveAccountBalancesWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RetrieveAccountBalancesResponse, error)

	// RetrieveAccountDetailsWithResponse request
	RetrieveAccountDetailsWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RetrieveAccountDetailsResponse, error)

	// RetrieveAccountTransactionsWithResponse request
	RetrieveAccountTransactionsWithResponse(ctx context.Context, id openapi_types.UUID, params *RetrieveAccountTransactionsParams, reqEditors ...RequestEditorFn) (*RetrieveAccountTransactionsResponse, error)

	// RetrieveAllEUAsForAnEndUserWithResponse request
	RetrieveAllEUAsForAnEndUserWithResponse(ctx context.Context, params *RetrieveAllEUAsForAnEndUserParams, reqEditors ...RequestEditorFn) (*RetrieveAllEUAsForAnEndUserResponse, error)

	// CreateEUAWithBodyWithResponse request with any body
	CreateEUAWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEUAResponse, error)

	CreateEUAWithResponse(ctx context.Context, body CreateEUAJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEUAResponse, error)

	CreateEUAWithFormdataBodyWithResponse(ctx context.Context, body CreateEUAFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateEUAResponse, error)

	// DeleteEUAByIDWithResponse request
	DeleteEUAByIDWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteEUAByIDResponse, error)

	// RetrieveEUAByIDWithResponse request
	RetrieveEUAByIDWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RetrieveEUAByIDResponse, error)

	// AcceptEUAWithBodyWithResponse request with any body
	AcceptEUAWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptEUAResponse, error)

	AcceptEUAWithResponse(ctx context.Context, id openapi_types.UUID, body AcceptEUAJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptEUAResponse, error)

	AcceptEUAWithFormdataBodyWithResponse(ctx context.Context, id openapi_types.UUID, body AcceptEUAFormdataRequestBody, reqEditors ...RequestEditorFn) (*AcceptEUAResponse, error)

	// RetrieveAllSupportedInstitutionsInAGivenCountryWithResponse request
	RetrieveAllSupportedInstitutionsInAGivenCountryWithResponse(ctx context.Context, params *RetrieveAllSupportedInstitutionsInAGivenCountryParams, reqEditors ...RequestEditorFn) (*RetrieveAllSupportedInstitutionsInAGivenCountryResponse, error)

	// RetrieveInstitutionWithResponse request
	RetrieveInstitutionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetrieveInstitutionResponse, error)

	// RetrieveAllRequisitionsWithResponse request
	RetrieveAllRequisitionsWithResponse(ctx context.Context, params *RetrieveAllRequisitionsParams, reqEditors ...RequestEditorFn) (*RetrieveAllRequisitionsResponse, error)

	// CreateRequisitionWithBodyWithResponse request with any body
	CreateRequisitionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRequisitionResponse, error)

	CreateRequisitionWithResponse(ctx context.Context, body CreateRequisitionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRequisitionResponse, error)

	CreateRequisitionWithFormdataBodyWithResponse(ctx context.Context, body CreateRequisitionFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateRequisitionResponse, error)

	// DeleteRequisitionByIDWithResponse request
	DeleteRequisitionByIDWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteRequisitionByIDResponse, error)

	// RequisitionByIDWithResponse request
	RequisitionByIDWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RequisitionByIDResponse, error)

	// ObtainNewAccessrefreshTokenPairWithBodyWithResponse request with any body
	ObtainNewAccessrefreshTokenPairWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ObtainNewAccessrefreshTokenPairResponse, error)

	ObtainNewAccessrefreshTokenPairWithResponse(ctx context.Context, body ObtainNewAccessrefreshTokenPairJSONRequestBody, reqEditors ...RequestEditorFn) (*ObtainNewAccessrefreshTokenPairResponse, error)

	ObtainNewAccessrefreshTokenPairWithFormdataBodyWithResponse(ctx context.Context, body ObtainNewAccessrefreshTokenPairFormdataRequestBody, reqEditors ...RequestEditorFn) (*ObtainNewAccessrefreshTokenPairResponse, error)

	// GetANewAccessTokenWithBodyWithResponse request with any body
	GetANewAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetANewAccessTokenResponse, error)

	GetANewAccessTokenWithResponse(ctx context.Context, body GetANewAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*GetANewAccessTokenResponse, error)

	GetANewAccessTokenWithFormdataBodyWithResponse(ctx context.Context, body GetANewAccessTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*GetANewAccessTokenResponse, error)
}

type RetrieveAccountTransactionsPremiumResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BankTransactionStatusSchema
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveAccountTransactionsPremiumResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAccountTransactionsPremiumResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAccountMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Account
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveAccountMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAccountMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAccountBalancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountBalanceSchema
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveAccountBalancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAccountBalancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAccountDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountDetailSchema
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveAccountDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAccountDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAccountTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BankTransactionStatusSchema
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveAccountTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAccountTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAllEUAsForAnEndUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedEndUserAgreementList
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveAllEUAsForAnEndUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAllEUAsForAnEndUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEUAResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EndUserAgreement
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON402      *ErrorResponse
	JSON403      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateEUAResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEUAResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEUAByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteEUAByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEUAByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveEUAByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndUserAgreement
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveEUAByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveEUAByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptEUAResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndUserAgreement
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AcceptEUAResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptEUAResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAllSupportedInstitutionsInAGivenCountryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Integration
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveAllSupportedInstitutionsInAGivenCountryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAllSupportedInstitutionsInAGivenCountryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveInstitutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationRetrieve
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveInstitutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveInstitutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAllRequisitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedRequisitionList
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveAllRequisitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAllRequisitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRequisitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpectacularRequisition
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON402      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateRequisitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRequisitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRequisitionByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteRequisitionByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRequisitionByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequisitionByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Requisition
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RequisitionByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequisitionByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ObtainNewAccessrefreshTokenPairResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpectacularJWTObtain
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ObtainNewAccessrefreshTokenPairResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ObtainNewAccessrefreshTokenPairResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetANewAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpectacularJWTRefresh
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON429      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetANewAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetANewAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// RetrieveAccountTransactionsPremiumWithResponse request returning *RetrieveAccountTransactionsPremiumResponse
func (c *ClientWithResponses) RetrieveAccountTransactionsPremiumWithResponse(ctx context.Context, id openapi_types.UUID, params *RetrieveAccountTransactionsPremiumParams, reqEditors ...RequestEditorFn) (*RetrieveAccountTransactionsPremiumResponse, error) {
	rsp, err := c.RetrieveAccountTransactionsPremium(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAccountTransactionsPremiumResponse(rsp)
}

// RetrieveAccountMetadataWithResponse request returning *RetrieveAccountMetadataResponse
func (c *ClientWithResponses) RetrieveAccountMetadataWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RetrieveAccountMetadataResponse, error) {
	rsp, err := c.RetrieveAccountMetadata(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAccountMetadataResponse(rsp)
}

// RetrieveAccountBalancesWithResponse request returning *RetrieveAccountBalancesResponse
func (c *ClientWithResponses) RetrieveAccountBalancesWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RetrieveAccountBalancesResponse, error) {
	rsp, err := c.RetrieveAccountBalances(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAccountBalancesResponse(rsp)
}

// RetrieveAccountDetailsWithResponse request returning *RetrieveAccountDetailsResponse
func (c *ClientWithResponses) RetrieveAccountDetailsWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RetrieveAccountDetailsResponse, error) {
	rsp, err := c.RetrieveAccountDetails(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAccountDetailsResponse(rsp)
}

// RetrieveAccountTransactionsWithResponse request returning *RetrieveAccountTransactionsResponse
func (c *ClientWithResponses) RetrieveAccountTransactionsWithResponse(ctx context.Context, id openapi_types.UUID, params *RetrieveAccountTransactionsParams, reqEditors ...RequestEditorFn) (*RetrieveAccountTransactionsResponse, error) {
	rsp, err := c.RetrieveAccountTransactions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAccountTransactionsResponse(rsp)
}

// RetrieveAllEUAsForAnEndUserWithResponse request returning *RetrieveAllEUAsForAnEndUserResponse
func (c *ClientWithResponses) RetrieveAllEUAsForAnEndUserWithResponse(ctx context.Context, params *RetrieveAllEUAsForAnEndUserParams, reqEditors ...RequestEditorFn) (*RetrieveAllEUAsForAnEndUserResponse, error) {
	rsp, err := c.RetrieveAllEUAsForAnEndUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAllEUAsForAnEndUserResponse(rsp)
}

// CreateEUAWithBodyWithResponse request with arbitrary body returning *CreateEUAResponse
func (c *ClientWithResponses) CreateEUAWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEUAResponse, error) {
	rsp, err := c.CreateEUAWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEUAResponse(rsp)
}

func (c *ClientWithResponses) CreateEUAWithResponse(ctx context.Context, body CreateEUAJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEUAResponse, error) {
	rsp, err := c.CreateEUA(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEUAResponse(rsp)
}

func (c *ClientWithResponses) CreateEUAWithFormdataBodyWithResponse(ctx context.Context, body CreateEUAFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateEUAResponse, error) {
	rsp, err := c.CreateEUAWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEUAResponse(rsp)
}

// DeleteEUAByIDWithResponse request returning *DeleteEUAByIDResponse
func (c *ClientWithResponses) DeleteEUAByIDWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteEUAByIDResponse, error) {
	rsp, err := c.DeleteEUAByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEUAByIDResponse(rsp)
}

// RetrieveEUAByIDWithResponse request returning *RetrieveEUAByIDResponse
func (c *ClientWithResponses) RetrieveEUAByIDWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RetrieveEUAByIDResponse, error) {
	rsp, err := c.RetrieveEUAByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveEUAByIDResponse(rsp)
}

// AcceptEUAWithBodyWithResponse request with arbitrary body returning *AcceptEUAResponse
func (c *ClientWithResponses) AcceptEUAWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptEUAResponse, error) {
	rsp, err := c.AcceptEUAWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptEUAResponse(rsp)
}

func (c *ClientWithResponses) AcceptEUAWithResponse(ctx context.Context, id openapi_types.UUID, body AcceptEUAJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptEUAResponse, error) {
	rsp, err := c.AcceptEUA(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptEUAResponse(rsp)
}

func (c *ClientWithResponses) AcceptEUAWithFormdataBodyWithResponse(ctx context.Context, id openapi_types.UUID, body AcceptEUAFormdataRequestBody, reqEditors ...RequestEditorFn) (*AcceptEUAResponse, error) {
	rsp, err := c.AcceptEUAWithFormdataBody(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptEUAResponse(rsp)
}

// RetrieveAllSupportedInstitutionsInAGivenCountryWithResponse request returning *RetrieveAllSupportedInstitutionsInAGivenCountryResponse
func (c *ClientWithResponses) RetrieveAllSupportedInstitutionsInAGivenCountryWithResponse(ctx context.Context, params *RetrieveAllSupportedInstitutionsInAGivenCountryParams, reqEditors ...RequestEditorFn) (*RetrieveAllSupportedInstitutionsInAGivenCountryResponse, error) {
	rsp, err := c.RetrieveAllSupportedInstitutionsInAGivenCountry(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAllSupportedInstitutionsInAGivenCountryResponse(rsp)
}

// RetrieveInstitutionWithResponse request returning *RetrieveInstitutionResponse
func (c *ClientWithResponses) RetrieveInstitutionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RetrieveInstitutionResponse, error) {
	rsp, err := c.RetrieveInstitution(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveInstitutionResponse(rsp)
}

// RetrieveAllRequisitionsWithResponse request returning *RetrieveAllRequisitionsResponse
func (c *ClientWithResponses) RetrieveAllRequisitionsWithResponse(ctx context.Context, params *RetrieveAllRequisitionsParams, reqEditors ...RequestEditorFn) (*RetrieveAllRequisitionsResponse, error) {
	rsp, err := c.RetrieveAllRequisitions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAllRequisitionsResponse(rsp)
}

// CreateRequisitionWithBodyWithResponse request with arbitrary body returning *CreateRequisitionResponse
func (c *ClientWithResponses) CreateRequisitionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRequisitionResponse, error) {
	rsp, err := c.CreateRequisitionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRequisitionResponse(rsp)
}

func (c *ClientWithResponses) CreateRequisitionWithResponse(ctx context.Context, body CreateRequisitionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRequisitionResponse, error) {
	rsp, err := c.CreateRequisition(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRequisitionResponse(rsp)
}

func (c *ClientWithResponses) CreateRequisitionWithFormdataBodyWithResponse(ctx context.Context, body CreateRequisitionFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateRequisitionResponse, error) {
	rsp, err := c.CreateRequisitionWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRequisitionResponse(rsp)
}

// DeleteRequisitionByIDWithResponse request returning *DeleteRequisitionByIDResponse
func (c *ClientWithResponses) DeleteRequisitionByIDWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteRequisitionByIDResponse, error) {
	rsp, err := c.DeleteRequisitionByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRequisitionByIDResponse(rsp)
}

// RequisitionByIDWithResponse request returning *RequisitionByIDResponse
func (c *ClientWithResponses) RequisitionByIDWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*RequisitionByIDResponse, error) {
	rsp, err := c.RequisitionByID(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequisitionByIDResponse(rsp)
}

// ObtainNewAccessrefreshTokenPairWithBodyWithResponse request with arbitrary body returning *ObtainNewAccessrefreshTokenPairResponse
func (c *ClientWithResponses) ObtainNewAccessrefreshTokenPairWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ObtainNewAccessrefreshTokenPairResponse, error) {
	rsp, err := c.ObtainNewAccessrefreshTokenPairWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObtainNewAccessrefreshTokenPairResponse(rsp)
}

func (c *ClientWithResponses) ObtainNewAccessrefreshTokenPairWithResponse(ctx context.Context, body ObtainNewAccessrefreshTokenPairJSONRequestBody, reqEditors ...RequestEditorFn) (*ObtainNewAccessrefreshTokenPairResponse, error) {
	rsp, err := c.ObtainNewAccessrefreshTokenPair(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObtainNewAccessrefreshTokenPairResponse(rsp)
}

func (c *ClientWithResponses) ObtainNewAccessrefreshTokenPairWithFormdataBodyWithResponse(ctx context.Context, body ObtainNewAccessrefreshTokenPairFormdataRequestBody, reqEditors ...RequestEditorFn) (*ObtainNewAccessrefreshTokenPairResponse, error) {
	rsp, err := c.ObtainNewAccessrefreshTokenPairWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObtainNewAccessrefreshTokenPairResponse(rsp)
}

// GetANewAccessTokenWithBodyWithResponse request with arbitrary body returning *GetANewAccessTokenResponse
func (c *ClientWithResponses) GetANewAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetANewAccessTokenResponse, error) {
	rsp, err := c.GetANewAccessTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetANewAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) GetANewAccessTokenWithResponse(ctx context.Context, body GetANewAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*GetANewAccessTokenResponse, error) {
	rsp, err := c.GetANewAccessToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetANewAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) GetANewAccessTokenWithFormdataBodyWithResponse(ctx context.Context, body GetANewAccessTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*GetANewAccessTokenResponse, error) {
	rsp, err := c.GetANewAccessTokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetANewAccessTokenResponse(rsp)
}

// ParseRetrieveAccountTransactionsPremiumResponse parses an HTTP response from a RetrieveAccountTransactionsPremiumWithResponse call
func ParseRetrieveAccountTransactionsPremiumResponse(rsp *http.Response) (*RetrieveAccountTransactionsPremiumResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAccountTransactionsPremiumResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BankTransactionStatusSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRetrieveAccountMetadataResponse parses an HTTP response from a RetrieveAccountMetadataWithResponse call
func ParseRetrieveAccountMetadataResponse(rsp *http.Response) (*RetrieveAccountMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAccountMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Account
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseRetrieveAccountBalancesResponse parses an HTTP response from a RetrieveAccountBalancesWithResponse call
func ParseRetrieveAccountBalancesResponse(rsp *http.Response) (*RetrieveAccountBalancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAccountBalancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountBalanceSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRetrieveAccountDetailsResponse parses an HTTP response from a RetrieveAccountDetailsWithResponse call
func ParseRetrieveAccountDetailsResponse(rsp *http.Response) (*RetrieveAccountDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAccountDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountDetailSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRetrieveAccountTransactionsResponse parses an HTTP response from a RetrieveAccountTransactionsWithResponse call
func ParseRetrieveAccountTransactionsResponse(rsp *http.Response) (*RetrieveAccountTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAccountTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Transactions BankTransactionStatusSchema `json:"transactions"`
		}

		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest.Transactions

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRetrieveAllEUAsForAnEndUserResponse parses an HTTP response from a RetrieveAllEUAsForAnEndUserWithResponse call
func ParseRetrieveAllEUAsForAnEndUserResponse(rsp *http.Response) (*RetrieveAllEUAsForAnEndUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAllEUAsForAnEndUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedEndUserAgreementList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseCreateEUAResponse parses an HTTP response from a CreateEUAWithResponse call
func ParseCreateEUAResponse(rsp *http.Response) (*CreateEUAResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEUAResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EndUserAgreement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeleteEUAByIDResponse parses an HTTP response from a DeleteEUAByIDWithResponse call
func ParseDeleteEUAByIDResponse(rsp *http.Response) (*DeleteEUAByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEUAByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseRetrieveEUAByIDResponse parses an HTTP response from a RetrieveEUAByIDWithResponse call
func ParseRetrieveEUAByIDResponse(rsp *http.Response) (*RetrieveEUAByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveEUAByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndUserAgreement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseAcceptEUAResponse parses an HTTP response from a AcceptEUAWithResponse call
func ParseAcceptEUAResponse(rsp *http.Response) (*AcceptEUAResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptEUAResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EndUserAgreement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseRetrieveAllSupportedInstitutionsInAGivenCountryResponse parses an HTTP response from a RetrieveAllSupportedInstitutionsInAGivenCountryWithResponse call
func ParseRetrieveAllSupportedInstitutionsInAGivenCountryResponse(rsp *http.Response) (*RetrieveAllSupportedInstitutionsInAGivenCountryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAllSupportedInstitutionsInAGivenCountryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Integration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseRetrieveInstitutionResponse parses an HTTP response from a RetrieveInstitutionWithResponse call
func ParseRetrieveInstitutionResponse(rsp *http.Response) (*RetrieveInstitutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveInstitutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationRetrieve
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseRetrieveAllRequisitionsResponse parses an HTTP response from a RetrieveAllRequisitionsWithResponse call
func ParseRetrieveAllRequisitionsResponse(rsp *http.Response) (*RetrieveAllRequisitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAllRequisitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedRequisitionList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseCreateRequisitionResponse parses an HTTP response from a CreateRequisitionWithResponse call
func ParseCreateRequisitionResponse(rsp *http.Response) (*CreateRequisitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRequisitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpectacularRequisition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeleteRequisitionByIDResponse parses an HTTP response from a DeleteRequisitionByIDWithResponse call
func ParseDeleteRequisitionByIDResponse(rsp *http.Response) (*DeleteRequisitionByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRequisitionByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseRequisitionByIDResponse parses an HTTP response from a RequisitionByIDWithResponse call
func ParseRequisitionByIDResponse(rsp *http.Response) (*RequisitionByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequisitionByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Requisition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseObtainNewAccessrefreshTokenPairResponse parses an HTTP response from a ObtainNewAccessrefreshTokenPairWithResponse call
func ParseObtainNewAccessrefreshTokenPairResponse(rsp *http.Response) (*ObtainNewAccessrefreshTokenPairResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ObtainNewAccessrefreshTokenPairResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpectacularJWTObtain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetANewAccessTokenResponse parses an HTTP response from a GetANewAccessTokenWithResponse call
func ParseGetANewAccessTokenResponse(rsp *http.Response) (*GetANewAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetANewAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpectacularJWTRefresh
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /api/v2/accounts/premium/{id}/transactions/)
	RetrieveAccountTransactionsPremium(ctx echo.Context, id openapi_types.UUID, params RetrieveAccountTransactionsPremiumParams) error

	// (GET /api/v2/accounts/{id}/)
	RetrieveAccountMetadata(ctx echo.Context, id openapi_types.UUID) error

	// (GET /api/v2/accounts/{id}/balances/)
	RetrieveAccountBalances(ctx echo.Context, id openapi_types.UUID) error

	// (GET /api/v2/accounts/{id}/details/)
	RetrieveAccountDetails(ctx echo.Context, id openapi_types.UUID) error

	// (GET /api/v2/accounts/{id}/transactions/)
	RetrieveAccountTransactions(ctx echo.Context, id openapi_types.UUID, params RetrieveAccountTransactionsParams) error

	// (GET /api/v2/agreements/enduser/)
	RetrieveAllEUAsForAnEndUser(ctx echo.Context, params RetrieveAllEUAsForAnEndUserParams) error

	// (POST /api/v2/agreements/enduser/)
	CreateEUA(ctx echo.Context) error

	// (DELETE /api/v2/agreements/enduser/{id}/)
	DeleteEUAByID(ctx echo.Context, id openapi_types.UUID) error

	// (GET /api/v2/agreements/enduser/{id}/)
	RetrieveEUAByID(ctx echo.Context, id openapi_types.UUID) error

	// (PUT /api/v2/agreements/enduser/{id}/accept/)
	AcceptEUA(ctx echo.Context, id openapi_types.UUID) error

	// (GET /api/v2/institutions/)
	RetrieveAllSupportedInstitutionsInAGivenCountry(ctx echo.Context, params RetrieveAllSupportedInstitutionsInAGivenCountryParams) error

	// (GET /api/v2/institutions/{id}/)
	RetrieveInstitution(ctx echo.Context, id string) error

	// (GET /api/v2/requisitions/)
	RetrieveAllRequisitions(ctx echo.Context, params RetrieveAllRequisitionsParams) error

	// (POST /api/v2/requisitions/)
	CreateRequisition(ctx echo.Context) error

	// (DELETE /api/v2/requisitions/{id}/)
	DeleteRequisitionByID(ctx echo.Context, id openapi_types.UUID) error

	// (GET /api/v2/requisitions/{id}/)
	RequisitionByID(ctx echo.Context, id openapi_types.UUID) error

	// (POST /api/v2/token/new/)
	ObtainNewAccessrefreshTokenPair(ctx echo.Context) error

	// (POST /api/v2/token/refresh/)
	GetANewAccessToken(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// RetrieveAccountTransactionsPremium converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveAccountTransactionsPremium(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params RetrieveAccountTransactionsPremiumParams
	// ------------- Optional query parameter "country" -------------

	err = runtime.BindQueryParameter("form", true, false, "country", ctx.QueryParams(), &params.Country)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter country: %s", err))
	}

	// ------------- Optional query parameter "date_from" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_from", ctx.QueryParams(), &params.DateFrom)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date_from: %s", err))
	}

	// ------------- Optional query parameter "date_to" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_to", ctx.QueryParams(), &params.DateTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date_to: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveAccountTransactionsPremium(ctx, id, params)
	return err
}

// RetrieveAccountMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveAccountMetadata(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveAccountMetadata(ctx, id)
	return err
}

// RetrieveAccountBalances converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveAccountBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveAccountBalances(ctx, id)
	return err
}

// RetrieveAccountDetails converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveAccountDetails(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveAccountDetails(ctx, id)
	return err
}

// RetrieveAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params RetrieveAccountTransactionsParams
	// ------------- Optional query parameter "date_from" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_from", ctx.QueryParams(), &params.DateFrom)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date_from: %s", err))
	}

	// ------------- Optional query parameter "date_to" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_to", ctx.QueryParams(), &params.DateTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date_to: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveAccountTransactions(ctx, id, params)
	return err
}

// RetrieveAllEUAsForAnEndUser converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveAllEUAsForAnEndUser(ctx echo.Context) error {
	var err error

	ctx.Set(JwtAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params RetrieveAllEUAsForAnEndUserParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveAllEUAsForAnEndUser(ctx, params)
	return err
}

// CreateEUA converts echo context to params.
func (w *ServerInterfaceWrapper) CreateEUA(ctx echo.Context) error {
	var err error

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateEUA(ctx)
	return err
}

// DeleteEUAByID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEUAByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteEUAByID(ctx, id)
	return err
}

// RetrieveEUAByID converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveEUAByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveEUAByID(ctx, id)
	return err
}

// AcceptEUA converts echo context to params.
func (w *ServerInterfaceWrapper) AcceptEUA(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AcceptEUA(ctx, id)
	return err
}

// RetrieveAllSupportedInstitutionsInAGivenCountry converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveAllSupportedInstitutionsInAGivenCountry(ctx echo.Context) error {
	var err error

	ctx.Set(JwtAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params RetrieveAllSupportedInstitutionsInAGivenCountryParams
	// ------------- Optional query parameter "access_scopes_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "access_scopes_supported", ctx.QueryParams(), &params.AccessScopesSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter access_scopes_supported: %s", err))
	}

	// ------------- Optional query parameter "account_selection_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "account_selection_supported", ctx.QueryParams(), &params.AccountSelectionSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account_selection_supported: %s", err))
	}

	// ------------- Optional query parameter "business_accounts_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "business_accounts_supported", ctx.QueryParams(), &params.BusinessAccountsSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter business_accounts_supported: %s", err))
	}

	// ------------- Optional query parameter "card_accounts_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "card_accounts_supported", ctx.QueryParams(), &params.CardAccountsSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter card_accounts_supported: %s", err))
	}

	// ------------- Optional query parameter "corporate_accounts_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "corporate_accounts_supported", ctx.QueryParams(), &params.CorporateAccountsSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter corporate_accounts_supported: %s", err))
	}

	// ------------- Optional query parameter "country" -------------

	err = runtime.BindQueryParameter("form", true, false, "country", ctx.QueryParams(), &params.Country)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter country: %s", err))
	}

	// ------------- Optional query parameter "payment_submission_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "payment_submission_supported", ctx.QueryParams(), &params.PaymentSubmissionSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_submission_supported: %s", err))
	}

	// ------------- Optional query parameter "payments_enabled" -------------

	err = runtime.BindQueryParameter("form", true, false, "payments_enabled", ctx.QueryParams(), &params.PaymentsEnabled)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payments_enabled: %s", err))
	}

	// ------------- Optional query parameter "pending_transactions_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "pending_transactions_supported", ctx.QueryParams(), &params.PendingTransactionsSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pending_transactions_supported: %s", err))
	}

	// ------------- Optional query parameter "private_accounts_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "private_accounts_supported", ctx.QueryParams(), &params.PrivateAccountsSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter private_accounts_supported: %s", err))
	}

	// ------------- Optional query parameter "read_refund_account_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "read_refund_account_supported", ctx.QueryParams(), &params.ReadRefundAccountSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter read_refund_account_supported: %s", err))
	}

	// ------------- Optional query parameter "ssn_verification_supported" -------------

	err = runtime.BindQueryParameter("form", true, false, "ssn_verification_supported", ctx.QueryParams(), &params.SsnVerificationSupported)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ssn_verification_supported: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveAllSupportedInstitutionsInAGivenCountry(ctx, params)
	return err
}

// RetrieveInstitution converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveInstitution(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveInstitution(ctx, id)
	return err
}

// RetrieveAllRequisitions converts echo context to params.
func (w *ServerInterfaceWrapper) RetrieveAllRequisitions(ctx echo.Context) error {
	var err error

	ctx.Set(JwtAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params RetrieveAllRequisitionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RetrieveAllRequisitions(ctx, params)
	return err
}

// CreateRequisition converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRequisition(ctx echo.Context) error {
	var err error

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateRequisition(ctx)
	return err
}

// DeleteRequisitionByID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteRequisitionByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteRequisitionByID(ctx, id)
	return err
}

// RequisitionByID converts echo context to params.
func (w *ServerInterfaceWrapper) RequisitionByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RequisitionByID(ctx, id)
	return err
}

// ObtainNewAccessrefreshTokenPair converts echo context to params.
func (w *ServerInterfaceWrapper) ObtainNewAccessrefreshTokenPair(ctx echo.Context) error {
	var err error

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ObtainNewAccessrefreshTokenPair(ctx)
	return err
}

// GetANewAccessToken converts echo context to params.
func (w *ServerInterfaceWrapper) GetANewAccessToken(ctx echo.Context) error {
	var err error

	ctx.Set(JwtAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetANewAccessToken(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v2/accounts/premium/:id/transactions/", wrapper.RetrieveAccountTransactionsPremium)
	router.GET(baseURL+"/api/v2/accounts/:id/", wrapper.RetrieveAccountMetadata)
	router.GET(baseURL+"/api/v2/accounts/:id/balances/", wrapper.RetrieveAccountBalances)
	router.GET(baseURL+"/api/v2/accounts/:id/details/", wrapper.RetrieveAccountDetails)
	router.GET(baseURL+"/api/v2/accounts/:id/transactions/", wrapper.RetrieveAccountTransactions)
	router.GET(baseURL+"/api/v2/agreements/enduser/", wrapper.RetrieveAllEUAsForAnEndUser)
	router.POST(baseURL+"/api/v2/agreements/enduser/", wrapper.CreateEUA)
	router.DELETE(baseURL+"/api/v2/agreements/enduser/:id/", wrapper.DeleteEUAByID)
	router.GET(baseURL+"/api/v2/agreements/enduser/:id/", wrapper.RetrieveEUAByID)
	router.PUT(baseURL+"/api/v2/agreements/enduser/:id/accept/", wrapper.AcceptEUA)
	router.GET(baseURL+"/api/v2/institutions/", wrapper.RetrieveAllSupportedInstitutionsInAGivenCountry)
	router.GET(baseURL+"/api/v2/institutions/:id/", wrapper.RetrieveInstitution)
	router.GET(baseURL+"/api/v2/requisitions/", wrapper.RetrieveAllRequisitions)
	router.POST(baseURL+"/api/v2/requisitions/", wrapper.CreateRequisition)
	router.DELETE(baseURL+"/api/v2/requisitions/:id/", wrapper.DeleteRequisitionByID)
	router.GET(baseURL+"/api/v2/requisitions/:id/", wrapper.RequisitionByID)
	router.POST(baseURL+"/api/v2/token/new/", wrapper.ObtainNewAccessrefreshTokenPair)
	router.POST(baseURL+"/api/v2/token/refresh/", wrapper.GetANewAccessToken)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"vwAAAP//mzct58lpAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
